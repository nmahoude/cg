/*#pragma GCC optimize("-O3")
#pragma GCC optimize("inline")
#pragma GCC optimize("omit-frame-pointer")
#pragma GCC optimize("unroll-loops")
*/

#include <iostream>
#include <chrono>
#include <string>
#include <algorithm>
#include <math.h>

using namespace std;
using namespace std::chrono;

//#define M_PI 3.14159265358979323846264338327
#define COEF_PATIENCE 0.9

// #define PROFILE
#define PROD
// #define DEBUG

#ifdef PROFILE

const int DURATIONS_COUNT = 1;
double durations[DURATIONS_COUNT];
high_resolution_clock::time_point starts[DURATIONS_COUNT];

    #define PS(i)   starts[i] = NOW;
    #define PE(i)   durations[i] = durations[i] + duration_cast<duration<double>>(NOW - starts[i]).count();
#else
    #define PS(i)
    #define PE(i)
#endif

high_resolution_clock::time_point start;
#define NOW high_resolution_clock::now()
#define TIME duration_cast<duration<double>>(NOW - start).count()

// ***********************************************************
constexpr double WIDTH = 16000.0;
constexpr double HEIGHT = 7500.0;

constexpr double INF = 16000*16000 + 7500*7500;


constexpr int SPELL_DEPTH = 8;
constexpr int POOL = 50;
constexpr double MUTATION = 2;

// ***********************************************************


int turn = 0;
int myScore = 0;
int hisScore = 0;
double energy = 0;
int depth = 0;

int smana;
int smyScore;
int shisScore;

Unit* unitsById[24];

Unit* spellTargets[4][20];
int spellTargetsFE[4];

bool doLog = false;

int victory;

// ***********************************************************
class Solution {
public:

  Solution* merge(Solution* solution) {
    Solution* child = new Solution();

    for (int i = 0; i < DEPTH; ++i) {
      if (fastRandInt(2)) {
        child->moves1[i] = solution->moves1[i];
        child->moves2[i] = solution->moves2[i];
      } else {
        child->moves1[i] = moves1[i];
        child->moves2[i] = moves2[i];
      }
    }

    if (fastRandInt(2)) {
      child->spellTurn1 = solution->spellTurn1;
      child->spellTarget1 = solution->spellTarget1;
      child->spell1 = solution->spell1;
    } else {
      child->spellTurn1 = spellTurn1;
      child->spellTarget1 = spellTarget1;
      child->spell1 = spell1;
    }

    if (fastRandInt(2)) {
      child->spellTurn2 = solution->spellTurn2;
      child->spellTarget2 = solution->spellTarget2;
      child->spell2 = solution->spell2;
    } else {
      child->spellTurn2 = spellTurn2;
      child->spellTarget2 = spellTarget2;
      child->spell2 = spell2;
    }


    return child;
  }

  void copy(Solution* solution) {
    for (int i = 0; i < DEPTH; ++i) {
      moves1[i] = solution->moves1[i];
      moves2[i] = solution->moves2[i];
    }

    spellTurn1 = solution->spellTurn1;
    spell1 = solution->spell1;
    spellTarget1 = solution->spellTarget1;
    spellTurn2 = solution->spellTurn2;
    spell2 = solution->spell2;
    spellTarget2 = solution->spellTarget2;

    this->energy = solution->energy;
  }

  void mutate();

  void randomize();
};


  void Wizard::end() {
    Unit::end();

    if (grab) {
      grab -= 1;

      if (!grab) {
            // Check if we can grab a snaffle
        for (int i = 0; i < snafflesFE; ++i) {
          Snaffle* snaffle = snaffles[i];

          if (!snaffle->dead && !snaffle->carrier && dist2(this, snaffle) < 159201.0) {
            grabSnaffle(snaffle);
            break;
          }
        }
      }
    }

    if (snaffle) {
      snaffle->x = x;
      snaffle->y = y;
      snaffle->vx = vx;
      snaffle->vy = vy;
    }

    if (spellTarget) {
      spells[spell]->cast(spellTarget);
      spellTarget = NULL;
    }
  }

  void Wizard::bounce(Unit* u) {
    if (u->type == SNAFFLE) {
      Snaffle* target = (Snaffle*) u;
      if (!snaffle && !grab && !target->dead && !target->carrier) {
        grabSnaffle(target);
      }
    } else {
      if (u->type == BLUDGER) {
        ((Bludger*) u)->last = this;
      }

      Unit::bounce(u);
    }
  }

  inline void Wizard::grabSnaffle(Snaffle* snaffle) {
    grab = 4;
    snaffle->carrier = this;
    this->snaffle = snaffle;

    // Stop the accio spell if we have one
    Spell* accio = this->spells[ACCIO];
    if (accio->duration && accio->target->id == snaffle->id) {
      accio->duration = 0;
      accio->target = NULL;
    }
  }

  void Wizard::apply(int move) {
    if (snaffle) {
        double coef = 500.0 * (1.0 / snaffle->m); // TODO WHY NOT PRECALCULATE ?
        snaffle->vx += cosAngles[move] * coef;
        snaffle->vy += sinAngles[move] * coef;
      } else {
        vx += cosAngles[move] * 150.0;
        vy += sinAngles[move] * 150.0;
      }
    }

    void Solution::mutate() {
      int r = fastRandInt(4);

      if (!r) {
        // Change a moves1
        moves1[fastRandInt(DEPTH)] = fastRandInt(ANGLES_LENGTH);
      } else if (r == 1) {
        // Change a moves2
        moves2[fastRandInt(DEPTH)] = fastRandInt(ANGLES_LENGTH);
      } else if (r == 2) {
        // Change spell1
        spellTurn1 = fastRandInt(SPELL_DEPTH);
        spell1 = fastRandInt(4);
        spellTarget1 = spellTargets[spell1][fastRandInt(spellTargetsFE[spell1])];
      } else {
        // Change spell2
        spellTurn2 = fastRandInt(SPELL_DEPTH);
        spell2 = fastRandInt(4);
        spellTarget2 = spellTargets[spell2][fastRandInt(spellTargetsFE[spell2])];
        spellTarget2->speed();
      }

    }

    void Solution::randomize() {
      for (int i = 0; i < DEPTH; ++i) {
        moves1[i] = fastRandInt(ANGLES_LENGTH);
        moves2[i] = fastRandInt(ANGLES_LENGTH);
      }

      spellTurn1 = fastRandInt(SPELL_DEPTH);
      spell1 = fastRandInt(4);
      spellTarget1 = spellTargets[spell1][fastRandInt(spellTargetsFE[spell1])];
      spellTurn2 = fastRandInt(SPELL_DEPTH);
      spell2 = fastRandInt(4);
      spellTarget2 = spellTargets[spell2][fastRandInt(spellTargetsFE[spell2])];

    }

// ****************************************************************************************

    bool mustErase(Collision* col, Unit* a, Unit* b) {
      if (a->id == col->a->id) {
        return true;
      }

      if (b != NULL && col->b != NULL) {
        if (a->id == col->b->id
          || b->id == col->a->id
          || b->id == col->b->id) {
          return true;
      }
    } else if (b != NULL) {
      if (b->id == col->a->id) {
        return true;
      }
    } else if (col->b != NULL) {
      if (a->id == col->b->id) {
        return true;
      }
    }

    return false;
  }

  void move() {
    double t = 0.0;
    double delta;

    Collision* next = fake;
    collisionsCacheFE = 0;
    collisionsFE = 0;
    tempCollisionsFE = 0;

    Collision* col;
    Unit* a;
    Unit* b;
    Unit* u;
    int i, j;

    // Get first collisions
    for (i = 0; i < unitsFE; ++i) {
      a = units[i];

      col = a->collision(t);

      if (col) {
        collisions[collisionsFE++] = col;

        if (col->t < next->t) {
          next = col;
        }
      }

      for (j = i + 1; j < unitsFE; ++j) {
        b = units[j];

        if (a->can(b)) {
          col = a->collision(b, t);

          if (col) {
            collisions[collisionsFE++] = col;

            if (col->t < next->t) {
              next = col;
            }
          }
        }
      }
    }

    while (t < 1.0) {
      if (next == fake) {
        for (i = 0; i < unitsFE; ++i) {
          units[i]->move(1.0 - t);
        }

        break;
      } else {
            // Move to the collision time
        delta = next->t - t;
        for (i = 0; i < unitsFE; ++i) {
          units[i]->move(delta);
        }

        t = next->t;

        if (next->dir) {
                /*if (doLog) {
                    cerr << next->a->id << " bounce with wall at " << t << endl;
                }*/
          next->a->bounce(next->dir);
        } else {
                /*if (doLog) {
                    cerr << next->a->id << " bounce with " << next->b->id << " at " << t << endl;
                }*/
          next->a->bounce(next->b);
        }

        a = next->a;
        b = next->b;

            // Invalid previous collisions for the concerned units and get new ones
        next = fake;

        for (i = 0; i < collisionsFE; ++i) {
          col = collisions[i];

          if (!mustErase(col, a, b)) {
            if (col->t < next->t) {
              next = col;
            }

            tempCollisions[tempCollisionsFE++] = col;
          }
        }

        Collision** temp = tempCollisions;
        tempCollisions = collisions;
        collisions = temp;

        collisionsFE = tempCollisionsFE;
        tempCollisionsFE = 0;

            // Find new collisions for a
        col = a->collision(t);
        if (col) {
          collisions[collisionsFE++] = col;

          if (col->t < next->t) {
            next = col;
          }
        }

        for (i = 0; i < unitsFE; ++i) {
          u = units[i];

          if (a->id != u->id && a->can(u)) {
            col = a->collision(u, t);

            if (col) {
              collisions[collisionsFE++] = col;

              if (col->t < next->t) {
                next = col;
              }
            }
          }
        }

            // Find new collisions for b
        if (b) {
          col = b->collision(t);

          if (col) {
            collisions[collisionsFE++] = col;

            if (col->t < next->t) {
              next = col;
            }
          }

          for (i = 0; i < unitsFE; ++i) {
            u = units[i];

            if (b->id != u->id && b->can(u)) {
              col = b->collision(u, t);

              if (col) {
                collisions[collisionsFE++] = col;

                if (col->t < next->t) {
                  next = col;
                }
              }
            }
          }
        }
      }
    }
  }

  void play() {
    for (int i = 0; i < 4; ++i) {
      spells[i]->apply();
    }

    bludgers[0]->play();
    bludgers[1]->play();
    wizards[0]->play();
    wizards[1]->play();
    wizards[2]->play();
    wizards[3]->play();

    for (int i = 5; i < 16; ++i) {
      spells[i]->apply();
    }

    move();

    for (int i = 0; i < unitsFE; ++i) {
      units[i]->end();
    }

    if (mana != 100) {
      mana += 1;
    }
  }

  double eval() {
    // Hidden ;)
    return 0;
  }

  void reset() {
    for (int i = 0; i < unitsFE; ++i) {
      units[i]->reset();
    }

    for (int i = 0; i < 16; ++i) {
      spells[i]->reset();
    }

    mana = smana;
    myScore = smyScore;
    hisScore = shisScore;
  }

  void dummies() {
    if (hisWizard1->snaffle) {
      hisWizard1->snaffle->thrust(500.0, hisGoal, dist(hisWizard1, hisGoal));
    } else {
      Snaffle* target = NULL;
      double targetD = INF;
      double d;

      for (int i = 0; i < snafflesFE; ++i) {
        Snaffle* snaffle = snaffles[i];

        if (!snaffle->dead) {
          d = dist2(hisWizard1, snaffle);

          if (d < targetD) {
            targetD = d;
            target = snaffle;
          }
        }
      }

      if (target) {
        hisWizard1->thrust(150.0, target, sqrt(targetD));
      }
    }

    if (hisWizard2->snaffle) {
      hisWizard2->snaffle->thrust(500.0, hisGoal, dist(hisWizard2, hisGoal));
    } else {
      Snaffle* target = NULL;
      double targetD = INF;
      double d;

      for (int i = 0; i < snafflesFE; ++i) {
        Snaffle* snaffle = snaffles[i];

        if (!snaffle->dead) {
          d = dist2(hisWizard2, snaffle);

          if (d < targetD) {
            targetD = d;
            target = snaffle;
          }
        }
      }

      if (target) {
        hisWizard2->thrust(150.0, target, sqrt(targetD));
      }
    }
  }

  void simulate(Solution* solution) {
    energy = 0;
    depth = 0;

    myWizard1->apply(solution, 0, 1);
    myWizard2->apply(solution, 0, 2);
    dummies();

    play();
    depth = 1;

    solution->energy = eval() * 0.1;

    for (int i = 1; i < DEPTH; ++i) {
      myWizard1->apply(solution, i, 1);
      myWizard2->apply(solution, i, 2);
      dummies();

      play();
      depth += 1;
    }

    solution->energy += energy + eval();

    reset();
  }

  void simulate2(Solution* solution) {
    doLog = true;

    cerr << "Solution: " << endl;
    for (int i = 0; i < DEPTH; ++i) {
      cerr << ANGLES[solution->moves1[i]] << " " << ANGLES[solution->moves2[i]] << endl;
    }
    cerr << "Spell 1: " << solution->spellTurn1 << " " << solution->spell1 << " " << solution->spellTarget1->id << endl;
    cerr << "Spell 2: " << solution->spellTurn2 << " " << solution->spell2 << " " << solution->spellTarget2->id << endl;

    energy = 0;
    depth = 0;

    myWizard1->apply(solution, 0, 1);
    myWizard2->apply(solution, 0, 2);
    dummies();

    play();

    cerr << "******* State at turn " << depth + 1 << endl;
    for (int i = 0; i < unitsFE; ++i) {
      units[i]->print();
    }
    depth = 1;

    solution->energy = eval() * 0.1;

    for (int i = 1; i < DEPTH; ++i) {
      myWizard1->apply(solution, i, 1);
      myWizard2->apply(solution, i, 2);
      dummies();

      play();

      cerr << "******* State at turn " << depth + 1 << endl;
      for (int i = 0; i < unitsFE; ++i) {
        units[i]->print();
      }
      depth += 1;
    }

    solution->energy += energy + eval();

    cerr << "Sanity check : " << solution->energy << endl;
    cerr << "Mana: " << mana << endl;
    cerr << "My score: " << myScore << endl;
    cerr << "His score: " << hisScore << endl;

    reset();

    doLog = false;
  }

// ****************************************************************************************
#define CATCH_CONFIG_MAIN  // This tells Catch to provide a main() - only do this in one cpp file
#include "catch.hpp"

unsigned int Factorial( unsigned int number ) {
    return number <= 1 ? number : Factorial(number-1)*number;
}

TEST_CASE( "Factorials are computed", "[factorial]" ) {
    REQUIRE( Factorial(1) == 1 );
    REQUIRE( Factorial(2) == 2 );
    REQUIRE( Factorial(3) == 6 );
    REQUIRE( Factorial(10) == 3628800 );
}


  int main2() {



    Solution* best = new Solution();

    int oldSnafflesFE;

    while (1) {
      int entities;
      cin >> entities; cin.ignore();
      start = NOW;

      int bludgersFE = 0;

      if (turn) {
        for (int i = 0; i < 24; ++i) {
          Unit* u = unitsById[i];

          if (u && u->type == SNAFFLE) {
            u->dead = true;
            u->carrier = NULL;
          }
        }
      }

      for (int i = 0; i < entities; i++) {
            int id; // entity identifier
            string entityType; // "WIZARD", "OPPONENT_WIZARD" or "SNAFFLE" (or "BLUDGER" after first league)
            int x; // position
            int y; // position
            int vx; // velocity
            int vy; // velocity
            int state; // 1 if the wizard is holding a Snaffle, 0 otherwise
            cin >> id >> entityType >> x >> y >> vx >> vy >> state; cin.ignore();

            Unit* unit;

            if (entityType == "WIZARD" || entityType == "OPPONENT_WIZARD") {
              unit = wizards[id];
            } else if (entityType == "SNAFFLE") {
              if (!turn) {
                unit = new Snaffle();
              } else {
                unit = unitsById[id];
              }

              unit->dead = false;
              units[unitsFE++] = unit;
              snaffles[snafflesFE++] = (Snaffle*)unit;
            } else if (entityType == "BLUDGER") {
              unit = bludgers[bludgersFE++];
            }

            unit->update(id, x, y, vx, vy, state);
          }

          if (turn == 0) {
            victory = (snafflesFE / 2) + 1;

            for (int i = 0; i < unitsFE; ++i) {
              unitsById[units[i]->id] = units[i];
            }
          }

        // Mise à jour des carriers et des snaffles
          for (int i = 0; i < 4; ++i) {
            wizards[i]->updateSnaffle();
          }

        // Mise à jour du score
          if (turn && oldSnafflesFE != snafflesFE) {
            for (int i = 0; i < 24; ++i) {
              Unit* u = unitsById[i];

              if (u && u->type == SNAFFLE && u->dead) {
                if (!myTeam) {
                  if (u->x > 8000) {
                    myScore += 1;
                  } else {
                    hisScore += 1;
                  }
                } else {
                  if (u->x > 8000) {
                    hisScore += 1;
                  } else {
                    myScore += 1;
                  }
                }

                delete u;
                unitsById[i] = NULL;
              }
            }
          }

        // Cibles pour les sorts

        // Bludgers pour tous les sorts
          for (int i = 0; i < 4; ++i) {
            spellTargets[i][0] = bludgers[0];
            spellTargets[i][1] = bludgers[1];
            spellTargetsFE[i] = 2;
          }

        // Wizards ennemis pour petrificus et flipendo
          if (!myTeam) {
            spellTargets[PETRIFICUS][spellTargetsFE[PETRIFICUS]++] = wizards[2];
            spellTargets[PETRIFICUS][spellTargetsFE[PETRIFICUS]++] = wizards[3];
            spellTargets[FLIPENDO][spellTargetsFE[FLIPENDO]++] = wizards[2];
            spellTargets[FLIPENDO][spellTargetsFE[FLIPENDO]++] = wizards[3];
          } else {
            spellTargets[PETRIFICUS][spellTargetsFE[PETRIFICUS]++] = wizards[0];
            spellTargets[PETRIFICUS][spellTargetsFE[PETRIFICUS]++] = wizards[1];
            spellTargets[FLIPENDO][spellTargetsFE[FLIPENDO]++] = wizards[0];
            spellTargets[FLIPENDO][spellTargetsFE[FLIPENDO]++] = wizards[1];
          }

        // Snaffles pour tous les sorts sauf obliviate
          for (int i = 1; i < 4; ++i) {
            for (int j = 0; j < snafflesFE; ++j) {
              spellTargets[i][spellTargetsFE[i]++] = snaffles[j];
            }
          }

          for (int i = 0; i < unitsFE; ++i) {
            units[i]->save();

            smana = mana;
            smyScore = myScore;
            shisScore = hisScore;
          }

          for (int i = 0; i < 16; ++i) {
            spells[i]->reloadTarget();
            spells[i]->save();
          }

        #ifndef PROD
          if (turn) {
            for (int i = 0; i < unitsFE; ++i) {
              units[i]->compare();
            }
          }
        #endif

        #ifndef PROD
          cerr << "hisScore : " << hisScore << endl;
          cerr << "snaffleCount : " << snaffleCount << endl;
          cerr << "victory : " << victory << endl;
        #endif

        /*cerr << "***** State for this turn " << endl;
        cerr << "Mana: " << mana << endl;
        cerr << "My score: " << myScore << endl;
        cerr << "His score: " << hisScore << endl;
        for (int i = 0; i < unitsFE; ++i) {
            units[i]->print();
        }*/

        // Evolution

          Solution* base;
          if (turn) {
            base = new Solution();

            for (int j = 1; j < DEPTH; ++j) {
              base->moves1[j - 1] = best->moves1[j];
              base->moves2[j - 1] = best->moves2[j];
            }

            base->spellTurn1 = best->spellTurn1;
            base->spell1 = best->spell1;
            base->spellTarget1 = best->spellTarget1;
            base->spellTurn2 = best->spellTurn2;
            base->spell2 = best->spell2;
            base->spellTarget2 = best->spellTarget2;

            if (!base->spellTurn1) {
              base->spellTurn1 = SPELL_DEPTH - 1;
            } else {
              base->spellTurn1 -= 1;
            }

            if (!base->spellTurn2) {
              base->spellTurn2 = SPELL_DEPTH - 1;
            } else {
              base->spellTurn2 -= 1;
            }

            if (base->spellTarget1->dead) {
              base->spellTurn1 = SPELL_DEPTH - 1;
              base->spellTarget1 = spellTargets[base->spell1][fastRandInt(spellTargetsFE[base->spell1])];
            }

            if (base->spellTarget2->dead) {
              base->spellTurn2 = SPELL_DEPTH - 1;
              base->spellTarget2 = spellTargets[base->spell2][fastRandInt(spellTargetsFE[base->spell2])];
            }

            delete best;
          }

          Solution** pool = new Solution*[POOL];
          Solution** newPool = new Solution*[POOL];
          Solution** temp;
          int counter = POOL;

          best = new Solution();
          Solution* sol = new Solution();
          sol->randomize();

          simulate(sol);
          pool[0] = sol;

          best->copy(sol);

          Solution* tempBest = sol;

        // First generation
          int startI = 1;

          if (turn) {
            // Populate the POOL with some copy of the previous best one
            for (int i = startI; i < POOL / 5; ++i) {
              Solution* solution = new Solution();
              solution->copy(base);

                // Add a last one random
              solution->moves1[DEPTH - 1] = fastRandInt(ANGLES_LENGTH);
              solution->moves2[DEPTH - 1] = fastRandInt(ANGLES_LENGTH);

              simulate(solution);

              if (solution->energy > tempBest->energy) {
                tempBest = solution;
              }

              pool[i] = solution;
            }

            delete base;

            startI = POOL / 5;
          }

          for (int i = startI; i < POOL; ++i) {
            Solution* solution = new Solution();
            solution->randomize();

            simulate(solution);

            if (solution->energy > tempBest->energy) {
              tempBest = solution;
            }

            pool[i] = solution;
          }

          if (tempBest->energy > best->energy) {
            best->copy(tempBest);
          }
          tempBest = best;

          double limit = turn ? 0.085 : 0.800;

        #ifdef DEBUG
            #define LIMIT counter <= 1000
        #else
            #define LIMIT TIME < limit
        #endif

          int generation = 1;
          int bestGeneration = 1;

          int poolFE;
          while (LIMIT) {
            // New generation

            // Force the actual best with a mutation to be in the pool
            Solution* solution = new Solution();
            solution->copy(tempBest);
            solution->mutate();
            simulate(solution);

            if (solution->energy > tempBest->energy) {
              tempBest = solution;
            }

            newPool[0] = solution;

            counter += 1;

            poolFE = 1;
            while (poolFE < POOL && LIMIT) {
              int aIndex = fastRandInt(POOL);
              int bIndex;

              do {
                bIndex = fastRandInt(POOL);
              } while (bIndex == aIndex);

              int firstIndex = pool[aIndex]->energy > pool[bIndex]->energy ? aIndex : bIndex;

              do {
                aIndex = fastRandInt(POOL);
              } while (aIndex == firstIndex);

              do {
                bIndex = fastRandInt(POOL);
              } while (bIndex == aIndex && bIndex != firstIndex);

              int secondIndex = pool[aIndex]->energy > pool[bIndex]->energy ? aIndex : bIndex;

              Solution* child = pool[firstIndex]->merge(pool[secondIndex]);

              if (!fastRandInt(MUTATION)) {
                child->mutate();
              }

              simulate(child);

              if (child->energy > tempBest->energy) {
                tempBest = child;
              }

              newPool[poolFE++] = child;

              counter += 1;
            }

            // Burn previous generation !!
            for (int i = 0; i < POOL; ++i) {
              delete pool[i];
            }

            temp = pool;
            pool = newPool;
            newPool = temp;

            if (tempBest->energy > best->energy) {
              best->copy(tempBest);
              bestGeneration = generation;
            }
            tempBest = best;

            generation += 1;
          }

        #ifndef PROD
          cerr << "Counter: " << counter << endl;
          cerr << "Energy: " << best->energy << endl;
          cerr << "Generation: " << generation << endl;
        #endif

        #ifdef DEBUG
        // Play a last time for debug
          simulate2(best);
        #endif

        // Play a last time to check some infos
          myWizard1->apply(best, 0, 1);
          myWizard2->apply(best, 0, 2);
          dummies();

          play();

/*        cerr << "***** State for next turn " << endl;
        cerr << "Mana: " << mana << endl;
        cerr << "My score: " << myScore << endl;
        cerr << "His score: " << hisScore << endl;
        for (int i = 0; i < unitsFE; ++i) {
            units[i]->print();
        }*/

          smana = mana;
          bludgers[0]->slast = bludgers[0]->last;
          bludgers[1]->slast = bludgers[1]->last;

          for (int i = 0; i < 16; ++i) {
            spells[i]->save();
          }

        #ifndef PROD
          for (int i = 0; i < unitsFE; ++i) {
            units[i]->store();
          }
        #endif

          reset();

        #ifdef PROFILE
          double totalSpent = 0;
          for (int i = 0; i < DURATIONS_COUNT; i++) {
            totalSpent += durations[i];
          }
          for (int i = 0; i < DURATIONS_COUNT; i++) {
            fprintf(stderr, "Time %3d: %.6fms (%.2f%%)\n", i, durations[i] * 1000.0, durations[i] * 100.0/totalSpent);
          }
          fprintf(stderr, "Total: %.6fms (%.6fms per turn)\n", totalSpent * 1000.0, totalSpent * 1000.0/(double)(turn + 1));
        #endif

          myWizard1->output(best->moves1[0], best->spellTurn1, best->spell1, best->spellTarget1);
          myWizard2->output(best->moves2[0], best->spellTurn2, best->spell2, best->spellTarget2);

        // Burn last generation !!
          for (int i = 0; i < poolFE; ++i) {
            delete pool[i];
          }

          delete [] pool;
          delete [] newPool;

          turn += 1;
          unitsFE = 10;

          oldSnafflesFE = snafflesFE;
          snafflesFE = 0;
        }
      }
