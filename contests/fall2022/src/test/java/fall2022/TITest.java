package fall2022;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import fall2022.Ilot.Ilot;
import fall2022.ai.AI;
import fast.read.FastReader;

public class TITest {
	AI ai = Player.ai;

	@BeforeAll
	static void setup() {
	}
	
	@BeforeEach
	void setup2() {
	}
	
	@Nested
	@Disabled
	class ATravailler {
		
		@Test
		@DisplayName(" (1,4) Ne doit pas viser 4,4 qui est déjà targetté par 2 units à cause d'une autre partie de l'algo")
		void dontTargetAlreadyTargetCellsBecauseOfAnotherAlgo() throws Exception {
			State state = read("""
		Global 
		^12 6
		Optional State : 
		^ 4
		^10 10
		^ 8192 21510 21510 13318 17414  9234 12288 20480 16384 12816 20992 16384 
		^17414 17414 17414 19462  9222 17426 21522 16384 16384 18432 21008 16384 
		^ 9222  3078  9222 17414 21522 17426 16384     0 18960 16384 16896 16384 
		^17414 16384 17414 19474     0 16384 16384 21008 16896  8192  2560  8192 
		^17414 21522 19474 16384 16384 21008 16928  8704 18944 16896 16896 16896 
		^16384 20480 12288 16384 20480 12288  8720 16896 12800 20992 20992  8192
		""");
			
			List<Action> commands = ai.think(state);
			
			assertThat(commands)
					.contains(Action.move(1, Pos.from(1,4), Pos.from(1,5), "TEST"))
					;
		}
		
		@Test
		@DisplayName("(7,3) et (8,2) ne doivent pas se rendre sur le même spot !")
		void dontMoveWith2UnitsOnTheSameUnchallengedFrontierSpot() throws Exception {
			State state = read("""
		Global 
		^13 6
		Optional State : 
		^ 4
		^14 20
		^    0  2560  8705 18944  8704  8720 16384 20480 16384 12288  8192     0     0 
		^12800  4609 14857 12801 18944 16912 16384 12288 16384 16384  9266 17414     0 
		^    0 16896 12801 12800 12816  8720 16384  8192  9234 17414  9222 13318     0 
		^    0 12800  8704 16384  8192  8192 16384  9234 13318 13318 17414 17414     0 
		^    0 16928  8720 16384 16384 12288 16384 16384 19474 17414 17415  9222 13318 
		^    0     0  8192 12288 16384 20480 16384  9234  9222 17415 11273     0     0
		""");
			
			List<Action> commands = ai.think(state);
			apply(state, commands);
			debug(commands);
			
			assertThat(commands)
				.contains(Action.move(1, Pos.from(7,3), Pos.from(6,3), "TEST"))
				.contains(Action.move(1, Pos.from(8,2), Pos.from(7,2), "TEST"))
					;
			
		}

		
		@Test
		void spawnAndAttack() throws Exception {
			State state = read("""
					  Global 
					^13 6
					Optional State : 
					^ 9
					^98 18
					^13330 0 17414 12288 0 8704 12816 16896 0 12800 16896 0 12816 
					^0 0 9222 19462 9222 0 10768 8704 16896 18944 8704 0 0 
					^0 0 9222 21510 11271 7177 6689 16896 16896 20992 8704 0 0 
					^16384 0 16384 20480 17414 7175 17426 12800 16896 20992 16912 0 16384 
					^12288 16384 12288 0 16384 17426 18944 16912 16896 0 12800 16896 12816 
					^0 20480 16384 8192 12288 19474 18960 18960 12800 8704 16912 20480 0		    
					""");
			
			List<Action> commands = ai.think(state);
			
			assertThat(commands)
							.contains(Action.move(1, Pos.from(5,4), Pos.from(6,4), "TEST"))
							.contains(Action.move(1, Pos.from(6,3), Pos.from(7,3), "TEST"))

							.contains(Action.spawn(1, Pos.from(5,5), "TEST"))
							// .contains(Action.move(1, Pos.from(5,5), Pos.from(6,5))) // est-ce que je dois vraiment attaquer celle ci ou défendre ?
													;
		}
		
		@Test
		@DisplayName("Move (8,1) to (8,0) to protect neutral cells behind")
		void move1() throws Exception {
			State state = read("""
				Global 
				^12 6
				Optional State : 
				^ 5
				^21 31
				^16384 0 8704 10753 16896 8704 16912 18432 8192 8192 16384 16384 
				^2561 6665 6657 10761 10753 12800 8720 16384 17426 16384 0 18432 
				^16913 10753 18944 12801 16896 12816 16384 17426 17414 0 17426 21510 
				^16905 12801 0 16896 16912 16912 13346 17414 19462 19462 11271 21510 
				^14337 0 16384 16912 16384 9234 13318 17414 17414 7175 7177 3079 
				^16384 16384 8192 8192 18432 17442 9222 17414 17414 9222 0 17414  
				""");
		
			List<Action> commands = ai.think(state);
			
			assertThat(commands).doesNotContain(Action.move(1, Pos.from(7,2), Pos.from(7,1), "TEST"));
		}
		
		
		
		@Test
		@DisplayName("Don't attack from 7,0 to 6,0 !")
		void dontAttackWhenNeedToDefendeGloabally() throws Exception {
			// étant donnée la situation, il vaut mieux build des recycler parce qu'on est plutot mal en défense ...
			
			State state = read("""
	Global 
	^16 8
	Optional State : 
	^ 12
	^12 18
	^12809  4609 16896 12800 16896 16896 21024 21522 21522 21510 17414 17414 12288 16384 12288 20480 
	^    0 16896     0 12800 16928 16896 20992 19462 19462 20480 16384 17414 13318     0 16384     0 
	^12800 20992  4608 17426 16896     0     0 17414 17414     0     0 16384 17414     0 20480 12288 
	^12800     0     0  9222 17414 17414 21510 13318 13318 21510 17414 17414  5126     0     0 12288 
	^12800     0     0     0     0 17414 21510 17414 17414 21510 17414     0 17414  5126  3078 12288 
	^20992 16896     0 16896     0 17414 16896 19462 19462 17414 16384     0 17414  3078 16384 20480 
	^    0     0 12800 12800 16384 21510 17414 19474 19462 17414 21510 17414 13318 13318     0     0 
	^16896 12800 16896     0 18432 20480 19474 17414 17414 19462 20480 18432     0 16384 12288 16384
			    """);
			
			List<Action> commands = ai.think(state);
			
			apply(state, commands);
			
			assertThat(commands).doesNotContain(
					Action.move(1, Pos.from(7, 0), Pos.from(6,0), "TEST"),
					Action.move(2, Pos.from(7, 0), Pos.from(6,0), "TEST")
					);
			
		}
	}
	

	
	
	
	@Test
	@DisplayName("Don't build at (13,3) je perds plein de cases !")
	void dontBuildToCutOneSelf() throws Exception {
		State state = read("""
Global 
^16 8
Optional State : 
^ 18
^33 28
^20480 16384     0 12288     0  8192  8192  2048 20480 12288     0  2048  2049     0 18432 16384 
^    0 12816 20480 10240     0 12288     0     0     0  5126     0     0  9225  3081 10241 16384 
^16384 12816  6144     0  8704 16896  2561     0  5129 11271  3090  9299 10761  7187     0 20480 
^16912  8720     0 10752  2560  2561  2569  5129     0     0     0 13318     0 13318 20480 16384 
^16912 20992  4608     0 16896 12800     0     0  3079     0     0     0     0     0 16384 16384 
^20480     0     0     0     0  4608     0     0  9225     0     0     0     0 16384 12288 16384 
^16912 21008 12800  2576 16896 16912  4624 16384  8193 10240     0     0 18432 20480 12288     0 
^16384 18432     0  8720  8704 12800 12816 20480 18432  8192  8192     0 12288     0 16384 20480
		    """);
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		
		assertThat(state.rec[Pos.from(13,3).o]).isZero();
		
	}

	@Test
	@DisplayName("Don't build at (1, 1) je me bloque !")
	void dontBuildToCutOneSelf2() throws Exception {
		State state = read("""
Global 
^17 8
Optional State : 
^ 0
^10 10
^    0  3090     0 12288 16384 16384  8192  8192 16384  8192  8192 16384 16384 12288     0  2576     0 
^ 3090  9222 17426 16384 18432 16384 18432 20480 12288 20480 18432 16384 18432 16384 16912  8704  2576 
^ 8192 17426 16384 12288     0 16384 16384 16384 20480 16384 16384 16384     0 12288 16384 16912  8192 
^    0 16384 16384 16384 18432  8192  8192  8192 16384  8192  8192  8192 18432 16384 16384 16384     0 
^    0 16384 16384     0 18432 16384 12288 18432 16384 18432 12288 16384 18432     0 16384 16384     0 
^12288  8192     0 12288 16384 12288 16384 20480 18432 20480 16384 12288 16384 12288     0  8192 12288 
^16384  8192 18432  8192 16384 12288     0 16384 16384 16384     0 12288 16384  8192 18432  8192 16384 
^12288  8192 12288     0 16384     0 16384  8192  8192  8192 16384     0 16384     0 12288  8192 12288
		    """);
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		
		assertThat(state.rec[Pos.from(1,1).o]).isZero();
		
	}

	@Test
	@DisplayName("Don't build on 8,0, it's not an automatic win")
	void notAWin() throws Exception {
		
		State state = read("""
Global 
^16 8
Optional State : 
^ 13
^38 34
^    0     0 16384 14337     0  9222 21510 19462 11271 19490     0 16384 16384  8192  8192     0 
^ 8192  9222 19463 15369  7175 15411 21510 11271  8713  2593 16912 16384 16384     0 16384 20480 
^    0 17414  8192 17415 17415  5129  9223 13319  4617  8737 16912  8704 20992  8704 16384 20480 
^16384 13318     0  9222 17414  9223  5127  5127  6665     0 16896  8704  8704 20992 20992     0 
^    0     0     0     0  9222  9223  3081 11273  4609 12800 12800 16896  8704 12800 12800 16384 
^20480 16384     0 21510  9222 17414  9223  9223 10761  2561  8704 20992 18944  8704 16896     0 
^20480 16384     0 16384 17426 17414 13318 11271 10761 12801 18960  8704 16896 20480  8192  8192 
^    0  8192  8192 16384 16384     0 13319 15369 10753 20992  8704     0 16384 16384     0     0
		    """);
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		
		assertThat(commands).doesNotContain(
				Action.build(Pos.from(8,0), "TEST")
				);
		
	}

	
	
	@Test
	@DisplayName("Defend neutral cell @(9,4)")
	void defendNeutralCell() throws Exception {
		State state = read("""
Global 
^16 8
Optional State : 
^ 10
^27 34
^    0  2560 12800     0 16896  9250 13319 17414 17414 21510  9222  4096     0  3090     0     0 
^16896  2560 12800 20992 12800  8705 12809  5127 13318 13319  5126     0  5126     0     0     0 
^16896  8704  8704 16896  2561 20992  8705 13321  9267  9225 13319     0 17414     0     0     0 
^ 8704     0 16896 10753 14857 10753 18945 12801 16928 13363 13319 17417 13319 17414  9222     0 
^ 6673 10761  8705     0 14849 18945 16905 16897 18960 18432 20480 16385     0 18432 20480 16384 
^12288 10241 16896 12800 16896 12800 16913 18432 18432 18432 12288 16384 12288 16384 20480 12288 
^12288 20480  8704  8704 20992 16912 18432 18432 18432 18432 16384 20480  8192  8192 20480 12288 
^ 8192 18432 12800 12816 20480  8192 18432     0     0 18432  8192 20480 12288 12288 18432  8192
		    """);
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		debug(commands);
		assertThat(state.u[Pos.from(9,3).o]).isGreaterThanOrEqualTo(1);
		
	}
	

	@Test
	@DisplayName("On va manquer d'unités dans quelques tours, il faut poser un recycler quelquepart ")
	void needMatterRecycler() throws Exception {
		State state = read("""
	Global 
	^23 11
	Optional State : 
	^ 2
	^10 20
	^12288 16384 16384     0 16384 16384  8192 20480 12288  8192 20480 18432 20480  8192 12288 20480  8192 16384 16384     0 16384 16384 12288 
	^18432     0 16384  8192     0 17414  9222 17426  8192 16384 16384  8192 16384 16384  8192 16912  8704 12801     0  8192 16384     0 18432 
	^18432  8192     0  8192 19462 21510 21510 21522 19474 18432 16384 12288 16384 18432 18960 21008 16897 16905 14849  8192     0  8192 18432 
	^    0  8192 16384  8192 13318 19462 13330  9234 16384 16384 16384 12288 16384 16384 16384  8720 12800 14849 12800  8192 16384  8192     0 
	^ 8192 16384  8192  8192  9234 12288 20480  8192 20480 12288 16384 20480 16384 12288 20480  8192 20480 12288  8720  8192  8192 16384  8192 
	^20480  8192 12288 20480 20480 18432  8192 18432 16384 20480 20480 16384 20480 20480 16384 18432  8192 18432 20480 20480 12288  8192 20480 
	^16384 18432 20480 20480  8192 20480  8192 20480 20480 20480 16384 20480 16384 20480 20480 20480  8192 20480  8192 20480 20480 18432 16384 
	^18432     0     0     0 16384 16384  8192 18432 18432 18432 12288 16384 12288 18432 18432 18432  8192 16384 16384     0     0     0 18432 
	^16384     0  8192 12288 16384 16384 20480 18432  8192 16384  8192  8192  8192 16384  8192 18432 20480 16384 16384 12288  8192     0 16384 
	^18432 12288     0     0     0 16384 20480 16384  8192 18432 16384 16384 16384 18432  8192 16384 20480 16384     0     0     0 12288 18432 
	^16384     0 20480 16384 16384  8192 16384 20480 12288 12288 16384  8192 16384 12288 12288 20480 16384  8192 16384 16384 20480     0 16384
		    """);
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		debug(commands);

		assertHasRecycler(commands);
	}

	@Test
	@DisplayName("Si on build en 12,10, on a perdu sûr")
	void dontBuildIfMeaningLose() throws Exception {
		State state = read("""
Global 
^24 12
Optional State : 
^ 25
^89 46
^    0  8192 16384     0  8704     0 20992 12800  4609  8713 13347     0 13318 21510 17414 12288 12288 20480     0  8192     0 16384  8192     0 
^ 8192 20480     0     0  8720     0 12800 16896 20992 10753     0     0  3078 17414 19462 20480 16384 12288     0  8192     0     0 20480  8192 
^20480 12288 16384 12288 18944  8704 16896     0     0 12800     0     0  3078     0 13318     0     0 17414  9222 19462 12288 16384 12288 20480 
^16384 18432 18944 16912  8704  8704     0 16384 16896  8704     0     0     0  5126  9222 16384 16384     0  9222  9222 16384 18432 18432 16384 
^16384 18432 20992  8704 18944 20992  8704 16896 16896 18944  2560     0     0  5126 19462 17414 17414  9222 21510 19462  8192 20480 18432 16384 
^16384 12816 12800  8704 16896 16896 18944 18944 16896 12800  4608     0     0 21510 13318 17414 19462 15367 17414 17414  8192 12288 12288 16384 
^20992 20992 18944 20992  8704 12800  8704 18944  8704 12800  8704     0     0  9222 13318  9222 15367  5129  9223  9222  9222 18432 20480 20480 
^16896     0 20992 12800 16896 18944 18944 18944     0 12800 16896     0     0     0 13318     0 19462 15367 18432  5126     0  8192     0 16384 
^16896  8704  8704 20992 18944 16896 16896 16896 16896 16896 16896  2560     0  3078 17414 17414 17426 17414 17414  7174  9222  9222  8192 16384 
^    0     0 16896 18944 12800 16896 18944 20992 16896     0 16896 14848     0 15366     0 17414 21510 13319  5126     0  7174 16384     0     0 
^    0  8704 12800 12800 16896 18944 16896 20992 20992  8704 12800 16944 13319 13318  9222 21510 15367 11273 12289  4096 12288 12288  8192     0 
^18944 12800     0 20992 16896 20992  8704 12800 18944 12800 16896  6657  7177 15367 13318 19462 13318  2049 20480 16384 20480     0 12288 18432
		    """);
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		debug(commands);
		
		assertThat(state.rec[Pos.from(12,10).o]).isZero();
	}

	@Test
	@DisplayName("(3,4) doit pas partir à perpette mais proteger 3,5 qui attaque 4,5")
	void dontMoveSoutienUnits() throws Exception {
		State state = read("""
Global 
^12 6
Optional State : 
^ 6
^13 10
^ 8192 21510 17415 15369 15367 17414 17414 17426  8720  8720 20992 12800 
^ 3078  3078  9222     0  9222 17426 21008 16912 16896 16896     0 20992 
^ 9222 19462 19462 19462 13318 13346 21008 18944 20992 12800 12800 20992 
^21510 13318 13318 21510 19462 21522 12832 12800 18944 18944 18944  8704 
^20480     0 17414 17426 17426 21522 16912  8704     0  8704  2560  2560 
^12288 20480  8192  9234 16912 16912 16896 16896 16896 18944 20992  8192 
		    """);
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		debug(commands);
		
		assertThat(commands).doesNotContain(
					Action.move(1, Pos.from(3,4), Pos.from(3,3), "test"),
					Action.move(1, Pos.from(3,4), Pos.from(2,4), "test")
				);
	}

	
	private void assertHasRecycler(List<Action> commands) {
		for (Action a : commands) {
			if (a.type() == Action.BUILD) return;
		}
		assertThat(true).as("Il n'y a pas de recycler dans "+commands).isFalse();
	}

	@Test
	@DisplayName("y'a des trous vers 11,6, on devrait pas rester dessus, meme pour attaquer ... ")
	void fleeFromHoles() throws Exception {
		State state = read("""
Global 
^22 11
Optional State : 
^ 12
^43 38
^ 8192 16384 16384 18432 16384 12288 12288 12288     0 16384 16384 16384 16384     0 12288 12288 12288 16384 18432 16384 16384  8192 
^16384 12288 18432 16384 12288 16384  2049     0  4097     0 20480 20480     0  8192     0 12288 16384 12288 16384 18432 12288 16384 
^    0     0  8192  8192     0  9223  7177  7175 17417 13319 11271  9267  8713 12801 16896 10753 18960     0  8192  8192     0     0 
^    0 16384 16384 10241 15369 11271 10241 13318  9223  7175 15369 10785 10785     0  6657 14857  6657 10761  6145 16384 16384     0 
^16384     0 16384  8192 11271     0 17414 13318  5127  9225     0     0  6673  2569     0 10753     0  6657  8704 16896     0 16384 
^16384     0 16384  8192     0     0     0     0 17414     0  3079  2569     0  2561     0     0     0     0  8704 16896     0 16384 
^12288 16384  8192 12288 12288     0     0     0     0  9222  9223  3123  2577     0     0     0     0 12288 12288  8192 16384 12288 
^    0  8192 18432 16384  8192 20480 20480     0 21510  9223 13321 12289 10761 14849     0 20480 20480  8192 16384 18432  8192     0 
^12288     0  8192 16384     0  8192 16384 16384  8192  8192     0     0  2049  8192 16384 16384  8192     0 16384  8192     0 12288 
^ 8192 12288     0 12288  8192 16384  8192  8192  8192 16384     0     0 16384  8192  8192  8192 16384  8192 12288     0 12288  8192 
^    0  8192  8192 16384 20480  8192 18432 20480 12288 12288 12288 12288 12288 12288 20480 18432  8192 20480 16384  8192  8192     0
		    """);
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		debug(commands);

		assertThat(state.u[Pos.from(10,6).o]).isEqualTo(3);
		
	}

	@Test
	@DisplayName("Frontier at 16,0 will disapear when unit will be there")
	void dontCrashIfReinforcementCantArriveInTime() throws Exception {
		State state = read("""
Global 
^19 9
Optional State : 
^ 11
^45 31
^12288  8192 16384     0 12288 18432 17426 12848 16896 12800 21510 17426 12288 12288 18432  8192  6145 18432 12288 
^20480  8192 18432     0 20480 12288  7175     0 12800     0 19462 18944     0  8192     0 16385 16905 10753 16896 
^12288  8192     0     0  8192  6145  3081  4609 16896 16896 11271     0     0     0  2569     0 18945  8192 12800 
^    0  8192 12288 16384     0 16384  9223  7177  8737 10753  7177  2049     0 20480     0 16384 16384     0  8704 
^ 8192 18432 16384 16384  8192  8193 13321  6673 10769  7177  5127  4617  2561 12288  8192 16384 16912 18944  8704 
^ 8192     0 16384 16384 16384 18433 13321  8705  5129  9225 18977  4609 20992 16384     0 16384 12288  8192     0 
^12288  8192 20480 18432 20480 13318 19463  7177  8193 14337 16912 17426 12800 12801  8192     0     0  8192 12288 
^16384 12288 18432 18432 16384  8192 19462 17415 19462     0 13318     0 12289  8713 16897     0 18432  8192 20480 
^12288 18432  8192  8192 18432 12288 12288 16384 21510 13318 17414 13318 17414 14337 12800     0 16384  8192 12288
				""");
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		
	}
	

	@Test
	@DisplayName("Don't attack the recycler at (6,3)")
	void attackValidTargets() throws Exception {
		State state = read("""
	Global 
	^13 6
	Optional State : 
	^ 4
	^20 30
	^ 8192  8192     0  8192 12288     0 12288  8192     0  8720 18944 18432     0 
	^ 8192  8192  8192 11271 13318     0 21008 16896  8704 16896  8704 18432     0 
	^ 8192 18432 11271 13321  9223 17414 11283 17442     0 10753  8704 16384 18432 
	^18432 16384  9222  9223     0 15379 10761 14849 10753 14857 12801 18432  8192 
	^    0 18432  9222 17414  9234 17414 18433     0 12800 12817  8192  8192  8192 
	^    0 18432 18432  8192     0  8192 12288     0 12800  8704     0  8192  8192
				""");
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		debug(commands);
		assertThat(commands).doesNotContain(Action.move(1, Pos.from(6,2), Pos.from(6,3), "TEST"));
	}

	@Test
	@DisplayName("Don't build at 1st turn because ilots in few turns")
	void dontBuild() throws Exception {
		State state = read("""
				Global 
				^12 6
				Optional State : 
				^ 0
				^10 10
				^8192 17426 0 18432 8192 8192 8192 8192 18432 0 16912 8192 
				^17426 17414 9234 20480 0 12288 12288 0 20480 8720 16896 16912 
				^16384 3090 16384 8192 20480 8192 8192 20480 8192 16384 2576 16384 
				^0 18432 16384 20480 20480 16384 16384 20480 20480 16384 18432 0 
				^16384 0 16384 20480 0 16384 16384 0 20480 16384 0 16384 
				^18432 12288 12288 8192 16384 20480 20480 16384 8192 12288 12288 18432
				""");
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		
		assertThat(state.rec[Pos.from(1,1).o]).isZero();
		
	}
	
	

	@Test
	@DisplayName("Doit defendre en 11,1 avant d'aller tapper la neutre en 11,0")
	void defendBeforeAttacking() throws Exception {
		State state = read("""
	Global 
	^23 11
	Optional State : 
	^ 16
	^38 50
	^12288  8192 16384     0 16384 12288  8192 16384 16384 12288 16384 12288 16384 12288 16912 16912  8192  8193 16384     0 16384  8192 12288 
	^20480     0 16384 18432 16384 16384 16384 20480  8192 12288  8192 17426  8720 10753  8704 20992 12801 12809 12289 18432 16384     0 20480 
	^12288 20480 20480  8192 18432 12288 12288  8192  8192 17415 19474 19462 17427 16905  6657  8704 12800  8705 18432  8192 20480 20480 12288 
	^ 8192     0 18432 20480 16384 16384 16384 16384 10241 15369  6689  8704  8704 14849 12800 16896 16896 16896  4609 20480 18432     0  8192 
	^ 8192 20480  8192 12288 16384 12288 16384 20480 10241 15369 14865 12800 16896 16896 12800 20992     0     0  4617     0  8192 20480  8192 
	^20480 12288     0 16384 18432 16384 18432 18432 12288  7175  9234 16912     0  8704 12800  2561  2569     0  6657 16896     0 12288 20480 
	^16384  8192  8192  8192 16384     0 16384     0 21510 21510  8753  6721  6665 10753 20992     0     0     0 16896  8704  8192  8192 16384 
	^12288     0 13318  9222 17414 17414 17414 21510  9222  9223  9225  8705  6657 16896     0 20992 16896     0 16896  8704 12800     0 12288 
	^16384 16384 17414 17414 17414 17414 17414 17414 11271  9225  4609 21008  4609     0     0     0     0     0     0     0 16896 16384 16384 
	^16384  8192  9222 21510 13318 12288     0 17414 17414  5127  7177  6673  6665  4609     0 16896     0     0     0     0     0  8192 16384 
	^    0     0 16384 13318 13318  9222 17414  9222     0 10241  5129 12809  4609 16896     0  8704 16896  8704 12800     0 16896     0     0
				""");
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		
		assertThat(state.u[Pos.from(11,1).o]).isGreaterThanOrEqualTo(1);
		
	}

	@Test
	@DisplayName("Ne doit pas spawn dans un recycler fraichement build en (6,4)")
	void dontSpawnIntoRecycler() throws Exception {
		State state = read("""
Global 
^15 7
Optional State : 
^ 10
^30 37
^    0 16896 16896 20992     0     0 18961 17417 15367  9234 20480 12288     0 12288     0 
^12800 16896 12800     0 16896 16896  8705 10769 18953 14337  8192 16384 16384 12288 18432 
^12800  2560  4608 12800 16896  6657  4617  8713  7187 19462     0 17426  4097  8192 16384 
^16896  4608     0     0 10753  6665  5139 15367 17414  9223 13321  5127  5129  8193 16384 
^16896  8704     0 16896     0  8721 13318 19463 17414 19462  9223 13318  7175  3078 12288 
^18960 12800 16896 16896  8704 16896 18961 15369 18433 16384 16384     0     0  4096 12288 
^    0 12288     0 12800 20992  8704 16912 16913 21522     0     0 20480  4096 16384     0 
				""");
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		
		if (state.rec[Pos.from(6,4).o] == 1 && commands.contains(Action.spawn(1, Pos.from(6,4), "Test"))) {
			throw new RuntimeException("Can't spawn in new recycler");
		}
		
	}

	@Test
	@DisplayName("recyclerAt75DoesntCreateNewIlots")
	void recyclerAt75DoesntCreateNewIlots() throws Exception {
		State state = read("""
Global 
^17 8
Optional State : 
^ 14
^32 24
^ 8704 16896  8704  8704 20992  8704  8704 18944  4609  7177     0  9222 21510  9222  9222 17414  8192 
^ 2560 16896  2560  8704 18944     0 16896  6656 17426  6657 10241     0 19462  9222  3078 17414  3078 
^18944  2560 18944 12800 16896 16896     0     0  4609  6665  7177 11271 17414 13318 19462  3078 19462 
^ 8704     0 12800 16896 12800 12800 10753  4609  9225 11273 11271 13318 13318 17414 13318     0  8192 
^    0 16384 16896 18944  8704  6657 14857 13331 11273 13319 21510 13318  9222 18432 16384 16384     0 
^16384 18432     0 18432  8704  8736  6673  9222  7175  9222 13318  8192  8192 18432     0 18432 16384 
^20480  8192 16384 16384 18944 16912 17426 21510 19462 20480 16384 16384 18432 16384 16384  8192 20480 
^16384 16384 16384 16384 16912 12816 21522 20480  8192 20480 20480 12288 16384 16384 16384 16384 16384
				""");
		
		//List<Action> commands = ai.think(state);
		
		apply(state, Arrays.asList(Action.build(Pos.from(7,5), "TEST")));
		List<Ilot> ilots = Ilot.build(state);
		assertThat(ilots.size()).isEqualTo(1);
	}



	@Test
	@DisplayName("Ne doit pas build un recycler en 6,4")
	void dontBuildRecyclerOnRecycler() throws Exception {
		State state = read("""
	Global 
	^15 7
	Optional State : 
	^ 10
	^30 37
	^    0 16896 16896 20992     0     0 18961 17417 15367  9234 20480 12288     0 12288     0 
	^12800 16896 12800     0 16896 16896  8705 10769 18953 14337  8192 16384 16384 12288 18432 
	^12800  2560  4608 12800 16896  6657  4617  8713  7187 19462     0 17426  4097  8192 16384 
	^16896  4608     0     0 10753  6665  5139 15367 17414  9223 13321  5127  5129  8193 16384 
	^16896  8704     0 16896     0  8721 13318 19463 17414 19462  9223 13318  7175  3078 12288 
	^18960 12800 16896 16896  8704 16896 18961 15369 18433 16384 16384     0     0  4096 12288 
	^    0 12288     0 12800 20992  8704 16912 16913 21522     0     0 20480  4096 16384     0
				""");
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		debug(commands);
		int count = 0;
		for( Action a : commands) {
			if (a.type() == Action.BUILD && a.to() == Pos.from(6,4)) count++;
		}

		assertThat(count).isLessThanOrEqualTo(1);
	}

	
	@Test
	@DisplayName("Doit defendre en 11,5 avant d'aller tapper la neutre en 11,4")
	void defendBeforeMoving() throws Exception {
		State state = read("""
	Global 
	^23 11
	Optional State : 
	^ 13
	^10 35
	^12288  8192 16384     0 16384 12288  8192 16384 16384 12288 16384 12288 16384 12288 16384 16384  8192 12288 16384     0 16384  8192 12288 
	^20480     0 16384 18432 16384 16384 16384 20480  8192 12288  8192 16384  8192 12288  8192 20480 16384 16912 16384 18432 16384     0 20480 
	^12288 20480 20480  8192 18432 12288 12288  8192  8192 18432 18432 18432 18432 18432  8720  8720 12800 12800 18432  8192 20480 20480 12288 
	^ 8192     0 18432 20480 16384 16384 16384 16384 12288 16384  8192  8192  8720 16912 12800 16896 16896 16896 10753 20480 18432     0  8192 
	^ 8192 20480  8192 12288 16384 12288 16384 20480 12288 16384 17426 13330 16896 16896 12800 20992  6657  6657 10761  6657  8192 20480  8192 
	^20480 12288     0 16384 18432 16384 18432 18432 12288  9222  9222 17442  4641  8704 12800  8705  8713  6657 12801 16896     0 12288 20480 
	^16384  8192  8192  8192 16384     0 16384     0 21510 21510 17414 13319 12809 16897 20992     0  6657     0 16896  8704  8192  8192 16384 
	^12288     0 13318  9222 17414 17414 17414 21510  9222 17414 17414 17414 12817 16896     0 20992 16896     0 16896  8704 12800     0 12288 
	^16384 16384 17414 17414 17414 17414 17414 17414 19462 17414 17414 21510 10753  4609  6665  4609     0     0     0     0 16896 16384 16384 
	^16384  8192  9222 21510 13318 12288     0 17414 17414 17414 19462 13319 12809 10769  4609 16896     0     0     0     0     0  8192 16384 
	^    0     0 16384 13318 13318  9222 17414  9222     0 16384 17414 18976 10753 16896     0  8704 16896  8704 12800     0 16896     0     0
				""");
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		
		assertThat(state.u[Pos.from(11,5).o]).isGreaterThanOrEqualTo(2);
		
	}
	
	@Test
	@DisplayName("Defendre la ligne de frontier en 6,2")
	void defendFrontierLine() throws Exception {
		State state = read("""
				Global 
				^13 6
				Optional State : 
				^ 2
				^20 10
				^16384 16384 20480 12288 12288 8192 16384 0 8192 16384 0 0 0 
				^8192 20480 8192 5127 19462 21522 16384 16384 16384 12288 8192 16384 0 
				^16384 16384 15367 17417 9223 19474 13330 18960 16912 16912 18944 0 0 
				^0 0 19462 13319 17414 19474 12816 18960 12800 20992 18944 16384 16384 
				^0 16384 9234 12288 16384 16384 16384 21008 18944 8704 8192 20480 8192 
				^0 0 0 16384 8192 0 16384 8192 12288 12288 20480 16384 16384
				""");
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		
		assertThat(state.u[Pos.from(6,2).o]).isGreaterThanOrEqualTo(2);
		assertThat(state.u[Pos.from(5,3).o]).isGreaterThanOrEqualTo(1);
		
	}

	@Test
	@DisplayName("4,5 doit aller vers 6,6 en passant par 4,6")
	void spreaderDoitEnvoyerVersLAFrontiereDuBas() throws Exception {
		State state = read("""
Global 
^15 7
Optional State : 
^ 4 0
^20 22
^    0 20480     0 17414 17414  9222  9234 20480  8192 20480 18432 20480     0     0  8192 
^    0 20480 16385 21510     0  8192 18432 18432 16384 18432  8720 16896     0  8192 12288 
^12288 12289  9225 17415  3078  9222 17442 17426 16384     0 16912  8704  8704 20480 12288 
^ 8192  8192 12289 13318  9222 17414 17414 16912 16912 16896  8704 12800 16896  8192  8192 
^12288 20480  8192  9222 17414     0 16384 16896 16896  8704  2560 14849 12800 16384 12288 
^12288  8192     0 17414  9234 19474 16384 18432 18960  8192     0 14857 14337 20480     0 
^ 8192     0     0 20480 18432 20480  8192 20480  8720  8704 16896 10753     0 20480     0 
				""");
		
		List<Action> commands = ai.think(state);
		
		apply(state, commands);

		assertThat(state.u[Pos.from(4,6).o]).isGreaterThanOrEqualTo(1);
		
		Action action = get(commands, Action.move(1, Pos.from(4,5), Pos.from(4,6), "TEST"));
		assertThat(action.realTarget).isEqualTo(Pos.from(6,6));
		assertThat(action.to).isEqualTo(Pos.from(4,6));
	}

	
	private Action get(List<Action> commands, Action action) {
		for (Action a : commands) {
			if (a.equals(action)) return a;
		}
		throw new RuntimeException("Action not found in commands not found : "+action);
	}

	@Test
	@DisplayName("Put a recycler on (8,6) : I kill 26 of my units ... but i win")
	void wierdRecycler() throws Exception {
		State state = read("""
Global 
^16 8
Optional State : 
^ 32
^16 14
^16896  8704     0     0 18944 18944 20992     0     0 20480 18432 18432     0     0     0 17414 
^16896 12800  8704 16896 16896 16896     0     0     0 17414 17414 17414 17414     0     0  5126 
^16896 16896 16896 16896 16896 20992     0     0  5126 21510 21510 17414 17414  5126  5126 17414 
^    0 16896 12800 16896 20992     0     0     0 17414 19462 19462 21510  5126     0  5126     0 
^12800 20992 18944 12800  8704  4608     0     0 13318 19462 17414  9222 13318  7174 21510 12288 
^    0 20992 12800 16896  8704  8704     0     0     0 16384  8192  8192 16384 12288 20480     0 
^    0 18944     0 18944  8704 16928  6672     0  3078 16384 16384  8192 18432     0 18432     0 
^    0  8704 18944  8704     0 16912     0  7088 17826     0 16384     0  8192 18432  8192     0
				""");
		
		List<Action> commands = ai.think(state);
		
		assertThat(commands)
				.containsAnyOf(Action.build(Pos.from(8,6), "TEST"))
				;
		
	}

	@Test
	@DisplayName("Protect 4,3 ")
	void protect43() throws Exception {
		State state = read("""
Global 
^12 6
Optional State : 
^ 5
^10 20
^    0  3078  9222 17414  9222 17426 12288 20480 16384 16384 18960  8192 
^17414  3078 13318 17414 13318 19474 18432 21008 16896 12800 20992 12288 
^    0 21510 19462 21510 19474 17442 16384 18960 20992 12801  8704 12288 
^12288  8192 17414 21510 19474 16912 16928 18944 16897 14857 16897     0 
^12288 20480 12288 17426 21538 18960 18944 12800 16896  8705  2560 16896 
^ 8192 18432 16384 16384 20480 12816 16896  8704 16896  8704  2560     0
				""");
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		debug(commands);
		
		assertThat(state.u[Pos.from(4,3).o]).isGreaterThanOrEqualTo(1);
		
	}

	@Test
	@DisplayName("Protect 4,4->4,5 pour couper les neutres derriere ")
	void protecteNeutralCells() throws Exception {
		State state = read("""
Global 
^13 6
Optional State : 
^ 9 0
^15 24
^ 8192 17414 13318 17414 21510 19463 19463 18953 18945 16896 12800 16896  8192 
^17414  9222 13318  9222  7175 15369 19475 14849  8704  8704 12800  8704 16896 
^ 9222  9222 19462     0 17414 19463 21510 16897 16896     0 18944  8704  8704 
^    0 17414 17414 17414 17414 17414 13331 12809 12801 16912 16896 16896     0 
^    0  8192 16384     0 13330 16384  8192 12289 12288     0 16896  8704     0 
^    0     0 16384 12288 12288 16384 16912 16896 12800 12800 16896     0     0

								""");
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		debug(commands);
		
		assertThat(state.u[Pos.from(4,5).o]).isGreaterThanOrEqualTo(1);
		
	}

	@Test
	@DisplayName("Block all opp units in 1,6")
	void blockOppUnitsWithRecycler() throws Exception {
		State state = read("""
		Global 
		^14 7
		Optional State : 
		^ 17 0
		^19 24
		^ 8192  8192 16384  8192  4096 17424 17408 14848 16896 20992  8192 16384  8192  8192 
		^    0 16384 19456     0     0  5120 15376 14856 18944 16896 16896 18432 16384     0 
		^    0  8192  9216 13312     0     0 13312     0 12800 16896 12800 16896  8192     0 
		^ 8192  4096     0  5120  9216     0     0     0     0  8704 12288  8704 12288  8192 
		^18432 12288 11264 17408 12288     0 11264     0     0     0  4608 18944 12288 18432 
		^12288     0 13312 21504 17408  9216     0     0     0  4608 20992 12800     0 12288 
		^    0  8864 13312  9216 13312 19456     0     0 18944 12800  8704 12288  8192     0 
				
								""");
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		debug(commands);
		
		assertThat(state.rec[Pos.from(2,6).o]).isGreaterThanOrEqualTo(1);
		
	}

	@Test
	@DisplayName("Pas de recycler en 6,4")
	void interditDePoserUnRecyclerQuiBloqueMaDefense() throws Exception {
		State state = read("""
Global 
^12 6
Optional State : 
^ 10 0
^18 27
^16384 16896     0  6657  6665 15367 21510 12288 12288     0 17414 16384 
^ 8704  2560 16896 16896 14849 16896 17426 21510 17414 17414  3078  9222 
^16896 16896  8704 20992 18944 16912 17426 15367 21510  9222 17414 16384 
^ 8192 18944  8192     0 12800 14865 13331  9225     0  9222 18432  8192 
^    0 20992 16896 16896 18945 14857 15367 17415 17414 17414 20480     0 
^12288  8192     0 12800 16896 14849 16384 16384 12288     0  8192 12288 				
								""");
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		debug(commands);
		
		assertThat(commands).doesNotContain(Action.build(Pos.from(6,4), "test"));
		
	}

	@Test
	@DisplayName("en 10,2, il va se renforcer d'au moins 2 unités (qui ne sont pas lock), on ne peut pas trop se dégarnir")
	void NePasEtreTropAggro() throws Exception {
		State state = read("""
Global 
^18 9
Optional State : 
^ 9 0
^52 24
^16384 18432 16385     0 18432 18432     0 12288 16384     0 20480 20480 18432 18432     0 12288 12288 20480 
^    0 12289 11273  9225     0 17414 21510 13318 15367 19462 17506     0 16384 12288 16384 20480     0     0 
^    0  3078 17415 13319  5126 19462 20480     0 15369 19475 12960 16928     0     0     0     0     0     0 
^    0 13318  3078  5126     0  7174 21510 17414 19463 20480     0 12800 18944 16896 16896 12800 12800 16384 
^20480 17414     0 21510  4096 16384     0 16384     0     0 10241     0 10753  6657 20992     0 16896 20480 
^16384 13318 13318 17414 17414 19462 13318     0 20992 14849 10761 14849  8713  2569  6657  2560 12800     0 
^    0     0     0     0     0     0 17442 12816 20992 16384     0 20480 12289  6657  6657 20992  2560     0 
^    0     0 20480 16384 12288 16384     0 16384 18432 16384 12288 20480 16384     0  2569  4609 16384     0 
^20480 12288 12288     0 18432 18432 20480 20480     0 16384 12288     0 18432 18432     0 20480 18432 16384
		""");

		// en vrai, il nous a attaquer avec 5
		List<Action> commands = ai.think(state);
		apply(state, commands);
		debug(commands);
		
		assertThat(state.u[Pos.from(10,1).o]).isGreaterThanOrEqualTo(6);
		
	}
	
	
	
	@Test
	@DisplayName("block ennemy with Recycler at 6,4 because we will win if we do")
	void blockEnnemy1() throws Exception {
		State state = read("""
				Global 
				^13 6
				Optional State : 
				^ 7
				^10 41
				^16384 16384 20480 13330 12288 9266 17414 0 8736 16384 0 0 0 
				^8192 20480 8192 9234 19462 21510 11271 8713 10753 12288 8192 16384 0 
				^16384 16384 19462 21510 13318 19462 5127 8713 8705 16896 18432 0 0 
				^0 0 19462 17414 17414 19462 3079 8713 2561 20992 18944 16384 16384 
				^0 16384 9222 13318 17414 17414 9223 10761 10753 8704 8192 20480 8192 
				^0 0 0 16384 8192 0 10768 0 6144 12288 20480 16384 16384
				""");
		
		List<Action> commands = ai.think(state);
		
		assertThat(commands)
				.containsAnyOf(Action.build(Pos.from(6,4), "TEST"))
				;
		
	}

	@Test
	@DisplayName("Dois spawn l'unité en bas pour ne pas 'croiser' les traces")
	void shouldSpawnEnBas() throws Exception {
		State state = read("""
				Global 
^12 6
Optional State : 
^ 0 0
^10 10
^    0 16384 16384 12288     0  8192  8192     0 12288 16384 16384     0 
^18432  8192  2576 12288 16384 18432 18432 16384 12288  3090  8192 18432 
^    0 16912 20992  8720 16384 16384 16384 16384  9234 21510 17426     0 
^12288  8192 16912 16384  8192 16384 16384  8192 16384 17426  8192 12288 
^12288     0 18432  8192 12288 16384 16384 12288  8192 18432     0 12288 
^20480     0 16384 16384  8192 16384 16384  8192 16384 16384     0 20480
				""");
		
		List<Action> commands = ai.think(state);
		
		assertThat(commands)
		.containsAnyOf(Action.spawn(1, Pos.from(9,3), "TEST"))
		;
		
	}



	
	
	

	
	@Test
	@DisplayName("8,4 doit aller vers le bas pour proteger la frontiere qu'il est le seul à proteger")
	void goSouthToProtectPath() throws Exception {
		State state = read("""
Global 
^14 7
Optional State : 
^ 8
^10 18
^    0  4608  8704     0 16896     0 18432 18432     0 16384     0  9222 17414 12288 
^ 4608 16896  2560 18944 16896 16928  9250  9234 17414 17414 19462  3078 17414 17414 
^    0 16896  8704 16896 18944 16912 21008 21510 17414 19462 17414  9222 17414     0 
^16384     0     0 16896 16896 20992 12800 13330 21510 17414 17414     0     0 16384 
^16384  8192 16384 16384 20992 18944 20480 21510 19474 20480 16384 16384  8192 16384 
^16384  8192 16384 16384 18432 16912     0     0 16384 18432 16384 16384  8192 16384 
^    0 12288 16384 16384 16384 12288 20480 20480 12288 16384 16384 16384 12288     0 
	""");
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		debug(commands);
		
		
		assertThat(commands).contains(Action.move(1, Pos.from(8,4), Pos.from(8,5), "TEST"));
		
	}

	@Test
	@DisplayName("14,8 doit aller vers le bas pour proteger")
	void goSouthToProtectPath2() throws Exception {
		State state = read("""
Global 
^24 12
Optional State : 
^ 7 0
^26 21
^16384     0 20480 16384     0 18432  8192 18432 16384  8192 20480  8192 18432 12288 16384 12288     0  8192 12288 18432 16384 12288 12288  8192 
^ 8192 20480 20480     0  8192  8192 16384 16912 18432  8192     0 16384 16384     0 20480 12288 16384 16384  8192     0 12288 20480     0     0 
^16384 16384  8192 16384 16384 12288 12288 12800  8720 18432     0 16384 16384 21522 16384 12288 18432 16384  8192 16384 20480 16384 12288  8192 
^16384 12288     0 16384     0 16896  8704 12800 12800 16896  8720  9234  8192 17414 12288 12288  8193 16384 16384 16384     0 16384  8192 12288 
^16384 16384 18432 12288 16384 16896 16896  6657 12800 16896 12816 19490 21510 13318 13318  7175  7177  9223 12288 12288 20480 20480     0 16384 
^16384  8192  8192     0 20480  8704  8705  8713  8705 18944 20992 16928 17426 21510  3079 19462     0 13319 21510  8192 16384 16384     0  8192 
^ 8192     0 16384 16384  8192 20992  8705     0 18944  8704 20992 16896 17426 15367 13321 13319 11271 11273     0 20480     0  8192  8192 16384 
^16384     0 20480 20480 12288     0  6665  4609 16896 12800 12800 20992 18976 13330 11271 13318 17414  9223 17414 16384 12288 18432 16384 16384 
^12288  8192 16384     0 16384 16384  4097 18432 12288 12800 16896  8720  8192  9234 17426 13318 13318  9222 16384     0 16384     0 12288 16384 
^ 8192 12288 16384 20480 16384  8192 16384 18432 12288 16896 21008 16384 16384     0 18432  8192 12288 12288 12288 16384 16384  8192 16384 16384 
^    0     0 20480 12288     0  8192 16384 16384 12288 20480     0 16384 16384     0  8192 18432 16384 16384  8192  8192     0 20480 20480  8192 
^ 8192 12288 12288 16384 18432 12288  8192     0 12288 16384 12288 18432  8192 20480  8192 16384 18432  8192 18432     0 16384 20480     0 16384 
	""");
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		debug(commands);
		
		
		assertThat(commands).contains(Action.move(1, Pos.from(14,8), Pos.from(14,9), "TEST"));
		
	}

	@Test
	@DisplayName("10,7 doit aller vers le bas pour proteger")
	void goSouthToProtectPath3() throws Exception {
		State state = read("""
Global 
^20 10
Optional State : 
^ 7 0
^20 19
^16384 16384 12288 20480 16384  8192 16384     0 16384 12288 21008 16384 16384  8192 18432 12288 16384     0     0 16384 
^    0  8192     0     0  8192 13318 17414 19474  9234 17426 18945 16384 18432 12288 16384 12288 12288 16384     0 12288 
^16384 12288  8192  8192 17414 17414 12288  9222 21510 15367 14857 14849 18944 16896  8705     0 18432 20480     0 18432 
^ 8192  8192  8192  8192  9222 18432 17414 17414 16384  9250 10785 20992 16384     0  4617  8193 18432 12288  8192 12288 
^20480 12288  8192 16384  9222 17414 17414 17414 17414 17426 21008 18944 16896 16896  8705  2560 16384  8192     0 16384 
^16384     0  8192 16384  3078 11271 17414 17414 19462 21522 16912 16896 16896 16896 16896  8704 16384  8192 12288 20480 
^12288  8192 12288 18432 10241  7177     0 17414 21510 13318  9234 16912 16896 16896 18944  8704  8192  8192  8192  8192 
^18432     0 20480 18432     0 11271 17414 19462 17414 17414 17426 21008  8704 12800 16896 16896  8192  8192 12288 16384 
^12288     0 16384 12288 12288 16384 12288 18432 16384 20480 16384  8192 18960 16912 12800  8192     0     0  8192     0 
^16384     0     0 16384 12288 18432  8192 16384 16384 20480 12288 16384     0 16384  8192 16384 20480 12288 16384 16384  
	""");
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		debug(commands);
		
		
		assertThat(commands).contains(Action.move(1, Pos.from(10,7), Pos.from(10,8), "TEST"));
		
	}

	@Test
	@DisplayName("Ne doit pas attacker full force en 7,3 vu qu'il y a une case neutre à côté !")
	void moveToNeutralCellInsteadOfAttacking() throws Exception {
		State state = read("""
	Global 
	^13 6
	Optional State : 
	^ 2
	^20 10
	^ 8192 16384 18432  8192 20480 16384 12288 20480 16384 18432     0 16384 12288 
	^ 8192 16384 12816 18432     0 16384 16384 17426 17414 13319 16384     0 20480 
	^12288 20480 16896 16896  8720  8720 20480 13330 15367 17417 13319 16384 20480 
	^20480 16384 16896 20992 18944 12816 21008  9250  9222 13331 17414 20480 12288 
	^20480     0 16384 16896 16896 16912 16384 16384     0 18432 12288 16384  8192 
	^12288 16384     0 18432 16384 20480 12288 16384 20480  8192 18432 16384  8192
	""");
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		
		assertThat(state.u[Pos.from(7,3).o]).isGreaterThanOrEqualTo(1);
		
	}

	
	@Test
	@DisplayName("si je pose 2 recyclers sur la frontier, je gagne !")
	void twoRecyclersCanMakeMeWin() throws Exception {
		State state = read("""
Global 
^14 7
Optional State : 
^ 13
^21 21
^20480  8192 13330 21510 17414  3079  4617  6657  4609  4617     0     0 4608     0 
^12288     0 17414 13318  5126     0     0 20992  2560  4609  8704  8704 4617  8704 
^    0 20480  9222  5126     0     0     0     0     0  2560  8704 16896  8720     0 
^ 8192 16384 17414     0  5126  5126     0     0     0  4608     0  4608 16384  8192 
^    0  8192     0     0     0  7175  9225     0  2569     0     0  8704 20480     0 
^ 8192 16384  8192     0 17414 19462 11271 12848     0  4608     0  4608     0 12816 
^    0 16384     0     0 16384 17414 21510  8705  6665  6657  8704 12816  8704 20992
	""");
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		
		assertThat(commands)
			.contains(Action.build(Pos.from(6,5), "TEST"))
			.contains(Action.build(Pos.from(6,6), "TEST"))
				;
		
	}
	

	@Test
	@DisplayName("ne devrait pas build @ 1,4 parce que ca créé un ilot qu'on risque de ne pas visiter !")
	void dontBuild1stRecyclerBecauseOfIlot() throws Exception {
		State state = read("""
	Global 
	^13 6
	Optional State : 
	^ 1
	^15 10
	^ 8192 12288 20480     0 16384 16384 16384 12288 16384 20480 16912     0  8192 
	^16384     0 12288 18432     0 16384 16384 12288 16384     0  8720  8192 12288 
	^    0 17426  7175 13330     0 20480 18432 12288 16912 16896 21008  8704  8192 
	^ 8192  7175 19465 15367 17426 12288 18432 20480     0 12816  8704 16384     0 
	^12288  8192  7175     0 16384 12288 16384 16384     0 18432 12288     0 16384 
	^ 8192     0 17426 20480 16384 12288 16384 16384 16384     0 20480 12288  8192
	""");
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		
		assertThat(state.rec[Pos.from(1,4).o]).isZero()
				;
		
	}

	
	@Test
	@DisplayName("devrait spawn des units en 15,4 pour aller proteger la frontiere !")
	void spawnUnitToProtectTheFrontier() throws Exception {
		State state = read("""
	Global 
	^23 11
	Optional State : 
	^ 16
	^40 22
	^    0 16384  8192     0  8192  8192 16384 13346 17414 13318  9222 17414 21510 13318 17414 13318 17414  9222  8192     0  8192 16384     0 
	^    0 18432 16384     0 16384  8192  9234  7175 17414     0     0     0 13318 21510 17414  9222  9222  9222 16384     0 16384 18432     0 
	^ 8192 18432 20480     0  2560 12800  6657 18953     0     0     0 11273     0 21510 17414 21510  9222  3078     0     0  4096 18432  8192 
	^16384  8192     0     0  2560     0 16896  6657 16896     0 14848     0     0  3079 17414  9222  7174     0 11270  3078  8192  8192 16384 
	^18432 12288  8192     0     0     0     0 20992 16896 18944 20992     0  5129  3081  7175 21510     0     0     0 16384  8192 12288 18432 
	^18432  8720 18944 16896  8704  2560 12800 18944 20992 16896 18944 12800  2561  6689 19465 16385 12288  2048  8192 16384 18432  8192 18432 
	^    0 16384 12288  8192 16384  8192 20480 16384 16384 16384 20992 16896 20992 14865 13321 14337 20480  8192 16384  8192 12288 16384     0 
	^    0 16384 16384 12288 12288 18432 12288 16384 16384 12288 20480 16896 21008  8705 13321 12289 12288 18432 12288 12288 16384 16384     0 
	^ 8192     0 12288  8192 12288  8192 16384 20480 20480     0 16384     0 16384     0 16385 20480 16384  8192 12288  8192 12288     0  8192 
	^ 8192 12288 20480 20480     0 16384  8192 16384 12288  8192 20480 12288 20480  8192 12288 16384  8192 16384     0 20480 20480 12288  8192 
	^18432  8192 18432 18432  8192 20480 12288 12288     0  8192 12288 20480 12288  8192     0 12288 12288 20480  8192 18432 18432  8192 18432
	""");
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		
		assertThat(state.u[Pos.from(15,4).o]).isGreaterThanOrEqualTo(1);
				;
	}

	@Test
	@DisplayName("en (12,7) Devrait attaquer la neutr plutot que la rouge")
	void attackNeutralIsBetterThanEnnemy() throws Exception {
		State state = read("""
	Global 
	^17 8
	Optional State : 
	^ 14
	^41 20
	^    0     0     0  8192  9222  9222  9223 16896 18944 16896  4608 16896 12800  8704 16896 12288  8192 
	^    0  8192     0  9222 19462 17415 13321 12817 16896  4608     0  4608 20992  4608  6656 12800     0 
	^ 8192 16384     0 17414 17414 14337 15369  6721 16896 16896  4608  8704  8704     0     0 10752  8704 
	^16384 13318 17414  9222  9222  7175 11273  6673  8705 12800 20992     0 16896  8704  2560  2560     0 
	^    0  3078 13318 17414 17414     0 15369  2561  9225  2561 16896 12800  8704  8704 16896 12288 16384 
	^ 9222 21510 19462  9222 17414  9222  3079 11273  6657  8704 20992 16896 16896 16896     0 16384  8192 
	^    0 13318 17414 13318 21510  5126     0  3079  9225  8721 14865 20992 18944  8704     0  8192     0 
	^ 8192 13318 17414  9222 13318 17414  5126 17414 11283 15379 11273  7175  9234  8192     0     0     0
	""");
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		
		assertThat(commands)
			.contains(Action.move(1, Pos.from(12,7), Pos.from(13,7), "TEST"))
				;
	}
	
	
	@Test
	@DisplayName("(7,4)Ne doit pas aller en 6,4 mais en 7,5 pour défendre la cellule neutre qui lui ouvre tout l'espace !")
	void DefendOnNeutralCell() throws Exception {
		State state = read("""
	Global 
	^13 6
	Optional State : 
	^ 8
	^14 26
	^    0  8704 18944  8704 14849 16913 19465 17415 17414  9222 19462  9222     0 
	^ 2569  4609 16896  6657 14857 15379 17415 17414 17414  9222 17414 11270 17414 
	^ 2561  8704 16896 12800 14849 21522 19462 21510 17414 13318  9222     0  9222 
	^ 8704 12800  8704 16896 18944  9234 13318  9222 19462 17414  9222  5126  9222 
	^12800 18944 16896 18944 16912 18432 17426 19474 17414 18432 16384 18432 12288 
	^16384 12288 16896 20992 16912 16896 16912 16384 16384 20480 16384 12288 16384 
	""");
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		debug(commands);
		assertThat(commands).
			contains(Action.move(1, Pos.from(7,4), Pos.from(7,5), "TEST"))
				;
		
	}

	
	
	@Test
	@DisplayName("Ne doit pas build en 9,2 parce que ça bloque la route de défense !")
	void recyclerNeDoitPasBloquerLaRoute() throws Exception {
		State state = read("""
	Global 
	^19 9
	Optional State : 
	^ 9
	^24 27
	^ 8192 12288 12288 16384     0 20480 12288 16384  8192 16384  8192 16384 12288 20480     0 16384 12288 12288  8192 
	^12288 16384 16384  8192 16384 12800 16896 18960 20480 16384 20480 18432 16384 12288 16384  8192 16384 16384 12288 
	^12288 12288 12800 12816  8193 16896     0 18960 12816 17414 12288 18432     0 16384 16384 12288 12288 12288 12288 
	^12288 12288 16896     0  8713 12801 16896  8720  8736 13394  5127  9222 17414 21510 17414     0 16384 12288 12288 
	^16384 16384 16896  6657 12801     0  6657 16896 16912 16385 13321 13319 17414     0 13319 11273  8193 16384 16384 
	^    0 16384  6657  4617     0 10753  6665     0 16896 16896 12289     0 17414  9223  3078  9223 18432 16384     0 
	^ 8192     0 16384     0  2569     0     0     0 12288 16384 12288     0     0  5129  9223  3078 16384     0  8192 
	^ 8192 18432 12288 16384     0  4617  2561 20992     0 17442     0 21510 17414  7175  3078 16384 12288 18432  8192 
	^12288 16384 18432 16384     0     0  8704  8705  4617 13319  9222 13318  9222  9222     0 16384 18432 16384 12288
	""");
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		
		assertThat(commands).
			doesNotContain(Action.build(Pos.from(9,2), "TEST"))
				;
		
	}

	
	@Test
	@DisplayName("Ne doit pas build en 9,4, y'a pas de danger et ca me kill 4 unités !")
	void dontBuildRecyclerThatBlocksMyArmies() throws Exception {
		State state = read("""
		Global 
	^17 8
	Optional State : 
	^ 10
	^14 21
	^    0     0     0 16896 18944 18944     0 16384 15367 11273 11271 13318 13318 21510     0 12288     0 
	^16896 16896 12800     0 12816 12800     0 20992     0 14337 16384 18432 16384 17414 13318 13318 12288 
	^    0 16896 20992 16896 12816     0 16896 21008     0 16384     0     0     0     0 16384 17414 16384 
	^16912 18944 18944     0 12800 16896 16896 14849  8713 17415 17414     0 13318 13318  3078 21510 21510 
	^20992 21008  2560 12800 12800     0 14849 18953  9283 19462 17414 17414 13318     0 19462 19462 16384 
	^16896 16896 16896     0     0     0     0 14337     0 21538 17414     0 13318 17414 21510 16384     0 
	^12800 12800 12800 16896 16896 18944 16896 16896     0 21538     0 12288 12288     0 12288 16384 16384 
	^    0 12800     0 20992 12800 12816 12288 12800 16896 16912     0 18432 18432 16384     0     0     0
	""");
		
		List<Action> commands = ai.think(state);
		
		assertThat(commands)
				.doesNotContain(Action.build(Pos.from(9,4), "TEST"))
				;
	}

	@Test
	@DisplayName("Ne doit pas build en 8,1, aucune raison !")
	void dontBuildRecyclerThatBlocksMyArmies2() throws Exception {
		State state = read("""
	Global 
	^15 7
	Optional State : 
	^ 8
	^36 35
	^ 8192 12288  8192  9234 13319 21510  7175 14857 14849  8704 12800 12800 18960 20992  8192 
	^    0 16384 20480 12289  5129  5127 17414  7187 13318     0  4609  8704  8704  6657 18960 
	^20480 12288 16384 12288 11271  9223 15367 11273  7187     0  4617     0 14849 14857 14849 
	^16384 20480  8192 10241  9225  5129 11271  7175  8713  2561     0 16896  4609 18961 16896 
	^16384 16384 16384  3078  7175  9223 17414 13319 11273 12801 16896  8705 12809  8705 20992 
	^18432  8192  8192     0  7177     0 13318 11271 13321  6657  8736 16896 16897 16896     0 
	^ 8192 20480 18432 12288     0  8192 20480 21554 10769 20992 16896  8704  8704 12816  8720
	""");
	
		List<Action> commands = ai.think(state);
		
		assertThat(commands)
				.doesNotContain(Action.spawn(1, Pos.from(16,3), "TEST"))
				;
	
	
	}
	
	
	
	@Test
	@DisplayName("Ne doit pas spawner en 16,3 parce que c'est la seule case avec 2 neutres autour")
	void dontSpawnBecauseLotOfNeutral() throws Exception {
		State state = read("""
	Global 
	^24 12
	Optional State : 
	^ 8
	^10 16
	^    0     0     0     0 12288     0     0 16384 16384     0     0     0 17426 19474 13362 17426 17426     0 16384 18432 16384     0 12288 16384 
	^    0     0 16384 20480 16384 12288 12288 16384     0 18432 16384 16384 18432 12288 17458     0 17442 21510     0  3078 16384 12288 12288     0 
	^12288 16384 18432     0 12288     0     0     0 12288     0 18432 18432     0 18432     0     0 13318 21510 17414 21510 17414 18432     0 18432 
	^    0     0 12288     0 16384     0 18432     0 12288 16384 16384 12288 20480 16384     0 16384 21510 19462 21510  3078     0 16384 12288 12288 
	^    0 20480 18432 16384 20480 18432 18432 18432     0     0 16384 16384 16384 20480 12288     0 12288     0     0 20480 20480 16384 20480     0 
	^    0 18960 16912     0 20480 20480 18432     0 16384 16384 12288 20480 18432 12288 12288 18432     0     0 16384 18432 20480 16384 12288 16384 
	^16896 12816 16912 21024 18960 16384     0     0 18432 12288 12288 18432 20480 12288 16384 16384     0 18432 20480 20480     0 16384 18432     0 
	^    0 21008 16896 20992 20992     0     0 12800     0 12288 20480 16384 16384 16384     0     0 18432 18432 18432 20480 16384 18432 20480     0 
	^12800 12800 16896     0     0 20992 18944 20992 16896     0 16384 20480 12288 16384 16384 12288     0 18432     0 16384     0 12288     0     0 
	^18944     0 18944     0  4617     0 20992 12800     0     0 18432     0 18432 18432     0 12288     0     0     0 12288     0 18432 16384 12288 
	^    0 12800 12816 16896     0     0 20992 16912     0 16384 12288 18432 16384 16384 18432     0 16384 12288 12288 16384 20480 16384     0     0 
	^16896 12800     0 16384 18432 16384     0 16928 16896 12800 18944 16912     0     0     0 16384 16384     0     0 12288     0     0     0     0
							""");
		
		List<Action> commands = ai.think(state);
		
		assertThat(commands)
				.doesNotContain(Action.spawn(1, Pos.from(16,3), "TEST"))
				;
		
	}
	
	
	@Test
	@DisplayName("doit spawn 1 en 15,8 et garder la position pour défendre")
	void spawnAndKeepPosition() throws Exception {
		State state = read("""
							Global 
							^23 11
							Optional State : 
							^ 25
							^19 17
							^0 0 18432 8192 16384 8192 0 9266 0 17414 17414 17414 5126 11270 0 11270 17414 17414 0 12288 12288 16384 16384 
							^12288 12288 16384 16384 12288 8192 0 11270 9222 0 0 0 0 0 0 0 13318 21510 9222 17414 0 12288 12288 
							^0 20480 18432 16896 20992 16896 14848 0 0 2569 0 0 0 6672 0 0 8192 0 8192 17414 17414 0 8192 
							^12288 0 20992 0 2560 18944 18944 2560 0 4609 18944 0 0 0 0 0 0 20480 0 21510 21510 9222 13318 
							^16384 0 0 0 0 20992 8704 16896 20992 16896 0 0 0 0 0 3078 17414 19462 17414 17414 17414 0 8192 
							^8192 16384 16896 0 16896 16896 12800 8704 20992 10752 0 0 0 0 3081 0 13318 17414 17414 21510 17414 16384 8192 
							^8192 0 16896 16896 16896 18944 16896 16896 16896 16896 0 0 0 0 3081 0 9222 20480 9222 0 17414 0 16384 
							^12288 8192 20992 20992 0 20480 0 16896 20992 4608 0 0 0 3081 0 8192 19462 18432 0 0 0 0 12288 
							^8192 0 16384 16896 8704 0 8704 8704 18944 20992 0 2560 0 0 0 9234 21510 17414 21510 0 18432 20480 0 
							^12288 12288 0 16384 8704 20992 18944 8704 16896 20992 16896 16896 0 0 18944 16928 0 8192 12288 16384 16384 12288 12288 
							^16384 16384 12288 12288 0 16896 16896 16896 16912 18944 20992 16896 16896 16896 0 8704 0 8192 16384 8192 18432 0 0
							""");
		
		List<Action> commands = ai.think(state);
		
		assertThat(commands)
				.containsAnyOf(Action.spawn(1, Pos.from(15,8), "TEST"))
				.doesNotContain(Action.move(1, Pos.from(15,8), Pos.from(15,9), "TEST"));
		
	}
	
	
	@Test
	@DisplayName("Protect blue before attacking red")
	void protectBeforeAttacking() throws Exception {
		State state = read("""
Global 
^16 8
Optional State : 
^ 7
^20 20
^    0 16384     0 16384 16384 12288 16384  8192  8192 20480 16384 16384  8192  8192 20480  8192 
^    0 16384 16384  8192 12800  8704 16896 21024 16912 17426  8192 16384 20480  8192 12288 16384 
^12288  8192  2560  4608 12800 20992 12800 18944 16896 17426 18432  8192  8192 16384 12288 12288 
^ 8192  2560 12800     0  8704 16896 16896 16912 17426 21510 17414 13318 13318 17414 12288 16384 
^16384 12800 16896  4608 12800 16896 20992 16384 17414 13319 17414 17426  9222 21510  3078  8192 
^12288 12800 16896  8192  8704 18944 16896 17414 15367  9225 17415 13318 13318  3078  9222 12288 
^16384 12800  8704 20992 16896  8704 16912 17426 20480 12289  8192 12288  8192 16384 16384     0 
^ 8192 20992  8704  8704 16912 16384 20480  8192  8192 16384 12288 16384 16384     0 16384     0
			""");
	
		List<Action> commands = ai.think(state);
		debug(commands);
		apply(state, commands);
		assertThat(state.u[Pos.from(9,0).o]).isGreaterThanOrEqualTo(1);
		assertThat(state.u[Pos.from(9,1).o]).isGreaterThanOrEqualTo(1);

	}

	@Test
	@DisplayName("Attaque 3,0 avec 6 unités")
	void doitAttaquerAvecSuffisament() throws Exception {
		State state = read("""
				Global 
^16 8
Optional State : 
^ 23
^17 22
^12800     0 16896 12849 12809  4609  4608 18944  8704 12800     0  8704     0 18944  8704 12800 
^ 6672     0     0 19666  9223     0     0  4608     0     0     0     0     0 16896 12800 12800 
^    0  5126 17414  9222 17414     0  9234     0     0  6665     0     0     0     0 12800  8704 
^    0 16384     0 17414     0     0     0     0     0  3123 10761 10753     0 16896 12816 18944 
^18432 12288     0  9222 21510     0     0  3078     0 13330 11271     0 16896     0 16928     0 
^ 8192     0     0  5126     0  3078     0     0     0     0     0 16896  8704 16896 16896     0 
^12288 12288     0  3078     0  3078     0  9222     0     0     0     0 18944 12800 12800 18944 
^12288  8192 18432     0     0 17426 13318  9222 19462 13318     0 16896 16896 16896     0 12800 

			""");
		
		List<Action> commands = ai.think(state);
		debug(commands);
		apply(state, commands);
		
		assertThat(commands).contains(Action.move(6, Pos.from(3,1), Pos.from(3,0), "TEST"));
		
	}

	
	

	@Test
	@DisplayName("Protect the empty cell in (5,4) bc other down")
	void MovetoNeutralAndProtect() throws Exception {
		State state = read("""
	Global 
	^12 6
	Optional State : 
	^ 7
	^21 19
	^ 8192     0 17414  9222 17414 19462 17443 14857  6657 16896 12800  8192 
	^ 5127  7177     0     0 17414 13330 12816 14849     0  8704 10753 18944 
	^13318  3079 19462 13318 17414 17414 16896 16896 12800  8705  6665  2561 
	^ 9222 13318  9222 17414 21522  9222  8704 20992 16912  8704  2561  8704 
	^16384  8192 12288 18432 21522 21522 21024 20992 18944 12800  8704 16384 
	^ 8192 12288 16384 16384  8192  8192  8720  8192 16384 16384 12288  8192
			""");
	
		List<Action> commands = ai.think(state);
		debug(commands);
		apply(state, commands);
		assertThat(state.u[Pos.from(6,0).o]).isGreaterThanOrEqualTo(1);
		assertThat(state.u[Pos.from(5,1).o]).isGreaterThanOrEqualTo(1);

		
		assertThat(state.u[Pos.from(5,4).o]).isGreaterThanOrEqualTo(1);

		// can't be sure on 55, so check command
		assertThat(commands).contains(Action.move(1, Pos.from(5,4), Pos.from(5,5), "TEST"));
	}

	
	@Test
	@DisplayName("Protect the empty cell bc other down (2)")
	void MovetoNeutralAndProtect2() throws Exception {
		State state = read("""
	Global 
	^12 6
	Optional State : 
	^ 8
	^14 28
	^ 8192     0 17414  9222 17414 19462 15395 12809  4609 16896 12800  8192 
	^ 3079  5129     0     0 17414 13330 12816 12801     0  8704  8705 18944 
	^13318     0 19462 13318 17414 17414 16896 16896 12800  6657  4617     0 
	^ 9222 13318  9222 17414 21510  9222  8704 21008 16896  8704     0  8704 
	^16384  8192 12288 18432 21522 21522 21008 20992 18944 12800  8704 16384 
	^ 8192 12288 16384 16384  8192  8192  8704  8192 16384 16384 12288  8192 
			""");
	
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		debug(commands);
		
		assertThat(state.u[Pos.from(6,0).o]).isGreaterThanOrEqualTo(1);
		assertThat(state.u[Pos.from(5,1).o]).isGreaterThanOrEqualTo(1);

		
		assertThat(state.u[Pos.from(5,4).o]).isGreaterThanOrEqualTo(1);

		// can't be sure on 55, so check command
		assertThat(commands).contains(Action.move(1, Pos.from(5,4), Pos.from(5,5), "TEST"));
	}
	
	
	@Test
	@DisplayName("Protect the cell @6,3 because 5,3 can pass")
	void protectDangerCell() throws Exception {
		State state = read("""
			Global 
			^12 6
			Optional State : 
			^ 5
			^21 31
			^16384 0 8704 10753 16896 8704 16912 18432 8192 8192 16384 16384 
			^2561 6665 6657 10761 10753 12800 8720 16384 17426 16384 0 18432 
			^16913 10753 18944 12801 16896 12816 16384 17426 17414 0 17426 21510 
			^16905 12801 0 16896 16912 16912 13346 17414 19462 19462 11271 21510 
			^14337 0 16384 16912 16384 9234 13318 17414 17414 7175 7177 3079 
			^16384 16384 8192 8192 18432 17442 9222 17414 17414 9222 0 17414  
			""");
	
		List<Action> commands = ai.think(state);
		
		apply(state, commands);
		assertThat(state.u[Pos.from(6,3).o]).isGreaterThanOrEqualTo(1); // protect 6,3
	}

	
	public static void debug(List<Action> commands) {
		System.err.println("Comamnds");
		for (Action c: commands) {
			c.debug();
		}
	}

	
	public static void apply(State state, List<Action> commands) {
		//System.err.println("Comamnds");
		for (Action c: commands) {
			//System.err.println(c);
			state.apply(c);
		}
	}

	@Test
	@DisplayName("Don't build a recycler turn 1, it blocks 2 of my units")
	void dontBuild1() throws Exception {
		State state = read("""
		  Global 
		  ^ 16 8
		  Optional State : 
		  ^ 0
		  ^ 10 10
		  ^ 0 17426 0 12288 8192 12288 20480 20480 20480 20480 12288 8192 12288 0 16912 0 
		  ^ 17426 3078 3090 12288 16384 8192 16384 18432 18432 16384 8192 16384 12288 2576 2560 16912 
		  ^ 18432 3090 12288 8192 8192 16384 16384 0 0 16384 16384 8192 8192 12288 2576 18432 
		  ^ 20480 0 16384 8192 16384 16384 8192 18432 18432 8192 16384 16384 8192 16384 0 20480 
		  ^ 20480 16384 16384 18432 16384 8192 20480 20480 20480 20480 8192 16384 18432 16384 16384 20480 
		  ^ 18432 16384 0 16384 18432 0 18432 16384 16384 18432 0 18432 16384 0 16384 18432 
		  ^ 12288 12288 8192 0 16384 12288 20480 16384 16384 20480 12288 16384 0 8192 12288 12288 
		  ^ 0 0 18432 12288 8192 16384 16384 20480 20480 16384 16384 8192 12288 18432 0 0
		  """);
	
		List<Action> commands = ai.think(state);
		
		assertThat(commands).doesNotContain(Action.build(Pos.from(1,1), "TEST"));
	}
	

	@Test
	@DisplayName("Don't kill ourself when scraps goes to 0")
	void dontKillYourself() throws Exception {
		State state = read("""
			Global 
			^14 7
			Optional State : 
			^ 12
			^84 26
			^12288 8192 8192 0 8704 0 13330 19462 13330 8192 16384 12288 8192 0 
			^12288 16928 8752 16928 21008 0 5126 19474 5155 2049 18432 18432 0 8192 
			^8720 16896 16896 2560 8704 2560 0 3079 4617 3081 0 19462 8192 20480 
			^8720 20992 12800 20992 0 0 5127 11270 0 0 0 0 20480 8192 
			^21008 8704 18944 12800 16896 4609 6665 0 0 0 0 16384 16384 8192 
			^8192 0 18944 18944 16896 16896 6657 10752 0 20480 16384 8192 16384 12288 
			^0 8192 12288 16384 8192 12816 18944 12800 0 8192 0 8192 8192 12288
		  """);
	
		List<Action> commands = ai.think(state);
		
		assertThat(commands).doesNotContain(Action.move(1, Pos.from(8,1), Pos.from(9,1), "TEST"));
	}

	@Test
	@DisplayName("Go optimally towards frontier")
	void optimal1stMove() throws Exception {
		State state = read("""
			Global 
			^16 8
			Optional State : 
			^ 1
			^15 10
			^0 0 0 20480 16384 16384 16384 18432 18432 16384 16384 16384 20480 0 0 0 
			^16384 8192 16384 12288 8192 16384 18432 12288 12288 18432 16384 8192 12288 16384 8192 16384 
			^8192 18432 8192 12288 12288 20480 18432 8192 8192 18432 20480 12288 12288 8192 18432 8192 
			^8192 18432 12288 12288 8192 16384 16384 18432 18432 16384 16384 8192 12288 12288 18432 8192 
			^8192 8192 18960 16896 18960 18432 12288 16384 16384 12288 18432 19474 15367 19474 8192 8192 
			^0 8192 18944 20992 18944 21008 16384 20480 20480 16384 21522 17415 19465 17415 8192 0 
			^12288 12288 8192 18960 18960 8192 12288 16384 16384 12288 8192 19474 17415 8192 12288 12288 
			^16384 8192 8192 16384 16384 18432 18432 20480 20480 18432 18432 16384 16384 8192 8192 16384 
		  """);
	
		List<Action> commands = ai.think(state);
		
		assertThat(commands)
						.contains(Action.move(1, Pos.from(11,4), Pos.from(10,4), "TEST"))
						.contains(Action.move(1, Pos.from(10,5), Pos.from(9,5), "TEST"))
						.contains(Action.move(1, Pos.from(11,6), Pos.from(10,6), "TEST"))
						// pas d'à priori pour le 4eme robot ...
						;
	}
	

	@Test
	@DisplayName("(5,4) will disapear, so dont protect it !")
	void dontProtectDyingCell() throws Exception {
		State state = read("""
	Global 
	^13 6
	Optional State : 
	^ 12
	^16 37
	^12288     0  9222 17414  9222 11270     0     0  2561 18944 16896  8704     0 
	^    0     0     0  5126 19462 19462 13319  2569  6665  6673     0     0 16896 
	^ 9222     0  5126     0  9222  3079  5127  8737 10769  4624     0     0  4608 
	^21510 18432 13318  5126 11271  4617  4617     0  8704     0     0     0     0 
	^17414 17414     0 17414 17414  3091  8713 12801 18944  4608  8704     0  8704 
	^    0  9222 17414 19462 13378  8752  2561 18944  8704 16896     0     0     0
		  """);
	
		List<Action> commands = ai.think(state);
		apply(state, commands);

		assertThat(state.u[Pos.from(5,4).o]).isZero();
		
	}

	
	@Test
	@DisplayName("Pop need unprotected frontier in 9,5 and prepare a spawn in 10,5")
	void protectedBySpawning() throws Exception {
		State state = read("""
	Global 
	^14 7
	Optional State : 
	^ 9
	^22 25
	^    0 16896 12800 18944  4609 16905 11271 17426 21522  9222 19462 12288 16384     0 
	^ 8192 16896 12800  8704  8704 12801  6665  7175 19462  9222  9222 12288 16384  8192 
	^18432 16896  8704 16896 16896 16912 10753 11273 11283 17414 17414  9222 16384 18432 
	^    0  2560 20992  2560 16896 16897 16905 12817 17417 15367  3078 21510  3078     0 
	^    0 16384 20992 18944     0 10761 15367 17426 11271     0 19462 21510 16384     0 
	^16384     0 12288 16896  8192 16897  8704  6657 17417  7175 17414 12288     0 16384 
	^16384  8192 16384 16896 18944 20992 12800 12800 18945 18960 16384 16384  8192 16384 
		  """);
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		
		assertThat(state.rec[Pos.from(9,5).o] == 1 || state.u[Pos.from(9,5).o] > 0).isTrue();
		assertThat(state.u[Pos.from(10,5).o]).isGreaterThanOrEqualTo(1);
	}

	@Test
	@DisplayName("Dont destruct 5 cells for a recycler in early game !")
	void dontBuildDestructorRecyclers() throws Exception {
		State state = read("""
Global 
^14 7
Optional State : 
^ 2
^14 22
^ 8192     0     0 20480 16384 18432     0 16384 16384  8192 20480 12288  8192 12288 
^12288  8192 16385 21510 13318 13330 18432 16384 16384  8192  8192 16384 12288 16384 
^ 8192 14337 15369 19463 19462 13318 21522 18432 16384  8192 18433 16384 12288  8192 
^18432 16384     0 19474 19474 17426  8192  8192 16912 16897 14857     0 16384 18432 
^ 8192 12288 16384 20480  8192 16384 18432 21008 12800 14849 16905 12801 16384  8192 
^16384 12288 16384  8192  8192 16384 16384 18432 12816 12800 16913 18944  8192 12288 
^12288  8192 12288 20480  8192 16384 16384     0 18432 16384 20480     0     0  8192 
		  """);
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		
		assertThat(state.rec[Pos.from(3,1).o] == 0).isTrue();
	}

	@Test
	@DisplayName("On a de quoi proteger la case en dispute en 6,3")
	void protectDisputedCell() throws Exception {
		State state = read("""
Global 
^13 6
Optional State : 
^ 6
^27 28
^ 6145 10761  6657  8704 16897 14865 19474 13319 17417  5127  9223 13321  8193 
^ 2560  6657  6657  4609 16905 12809 17427 15369 17415  9222 13318  9223  3078 
^    0  6657  2569 10753  4609 14865 16912 15367  9222 17414  9222 13318     0 
^16384 12800 10753 16896  8720 16384 18432 17426  9222 17414 17414 13318 16384 
^16384     0 16896 16896 18960 16384 16384 16384 19474 17426 17414     0 16384 
^16384 16384 18944  8720  8192  8192  8192  8192  8192  8192 18432 16384 16384 
		  """);
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		
		assertThat(state.countBlueAround(Pos.from(6,3))).isGreaterThanOrEqualTo(1);
	}

	@Test
	@DisplayName("si on build en 6,4, on évite de spawn 2 unités, on save la case bleue en 6,5 et on grignotte la 6,3 à lui")
	void buildCanSaveMyTerritoryAndGainOpp() throws Exception {
		State state = read("""
Global 
^12 6
Optional State : 
^ 12
^31 21
^16384  8704     0 12288  8192  8721 17414  8192 12288     0  9222 16384 
^ 8704  8704 16896     0     0  8713  9223     0     0 17414  9222  5127 
^16896 20992  8704 12800  8704  4625  5129     0 13318  9222 17415 13321 
^18944 18944 16896  8704     0  6657  8737     0  9222 17414 19462 15367 
^18944 16896 16896 16896  6657 10761 11271 15369 15379 17414 16384 18432 
^    0 18432 12288  8192     0  2049 13318     0  8192 12288 18432     0
		  """);
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		
		assertThat(commands).contains(Action.build(Pos.from(6,4),"Test"));
	}

	@Test
	@DisplayName("6,1 doit plutot aller vers le bas pour proteger la neutral au lieu de celle du haut qui n'est pas dangereuse")
	void defendNeutralCellsInDangerBeforeNeutralWithoutDanger() throws Exception {
		State state = read("""
Global 
^13 6
Optional State : 
^ 5
^26 31
^ 8193 12809  8705  8704 18945 16896 18432 15367 19465  7175 11271 15369 10241 
^ 2560  8705  8705  6657 18953 14849 19474 17414 19463  9222 13318 11271  3078 
^    0  8705  4617 12801  6657 16912 16384 17414  9222 17414  9222 13318     0 
^16384 12800 12801 16912  8192 16384 18432 16384  9234 17426 17414 13318 16384 
^16384     0 16896 16912 18432 16384 16384 16384 18432 17426 17414     0 16384 
^16384 16384 18960  8192  8192  8192  8192  8192  8192  8192 18432 16384 16384 
		  """);
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		
		assertThat(commands).contains(
				Action.move(1, Pos.from(6,1), Pos.from(6,2),"Test"),
				Action.spawn(1, Pos.from(6,1), "Test") // pour préparer la suite
				);
	}

	
	@Test
	@DisplayName("avec 30 matter, on peut bien defendre & attaquer les neutrals")
	void goodDefense() throws Exception {
		State state = read("""
Global 
^13 6
Optional State : 
^ 7
^32 19
^16384 20992 16896  8704 16897 10761 15367 15369 19463  5127 13321 17415 16384 
^ 2560 16896 12800  8704 14849 10761 13319 15367 21510  9222  9223 17414  3078 
^    0 12800  8704 16896  8704 10769 17414 17414  9222 17414  9222 13318     0 
^16384 12288 16896 16896  8704 16912 18432 17426  9222 17414 17414 12288 16384 
^16384     0 16384 16896 18944 16896 16912 17426 19462 17414 17414     0 16384 
^16384 16384 18432  8704  8720  8192  8192  8192  8192  8192 18432 16384 16384
		  """);
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		
		assertThat(commands).contains(
				Action.spawn(1, Pos.from(6,2), "Test"),
				Action.move(1, Pos.from(7,3), Pos.from(6,3),"Test"),
				Action.spawn(1, Pos.from(7,4), "Test"), 
				Action.move(1, Pos.from(7,4), Pos.from(7,5),"Test")
				);
	}

	@Test
	@DisplayName("Need to spawn units as my matter is big and opp's low so I CAN WIN")
	void spawnALotSomewhere() throws Exception {
		State state = read("""
Global 
^19 9
Optional State : 
^ 16
^73 18
^    0  8192  8192 12288 12288     0  8192  8192 13330 21008  8704 16384 18432  8192  8192 16384     0 12288     0 
^16384     0     0     0 18432 20480 16384 18432 19462     0 18944  8704 16896 16896 16896     0  8192 16384 16384 
^12288  8192 18432     0 16384 20480     0 13318     0     0  8192  8192 16384     0  8704 18432     0 18432  8192 
^12288     0 12288  8192 17414     0 19462     0     0     0 18944  8704  8704     0     0 20992  8192 12288 18432 
^    0  8192 12288     0  5126     0     0  3078     0     0 16896 16896  2560     0     0     0 12288  8192     0 
^18432 12288     0     0     0     0  9222  9222  5126 17426 16912 12800 18944  2560     0  8704 12288     0 12288 
^ 8192 18432     0     0     0     0 16384  9222 17414  9234  8720 12288     0 20480 16384     0 18432  8192 12288 
^16384 16384  8192     0     0     0 16384  8192 19462     0 18944 18432 16384 20480 18432     0     0     0 16384 
^    0 12288     0 16384     0  9222 19462 17414  9222 21522 12816  8192  8192     0 12288 12288  8192  8192     0  
		  """);
		
		List<Action> commands = ai.think(state);
		apply(state, commands);
		debug(commands);
		
		int spawnCount = 0;
		for (Action a : commands) {
			if (a.type() == Action.SPAWN) spawnCount+=a.amount;
		}

		assertThat(spawnCount).isGreaterThan(4);
	}
	
	
	@Nested
	@Disabled("ne semble pas apporter d'avantage ... ")
	class PasDeGainAReessayer {
		@Test
		@DisplayName("Crush Last Cell")
		void crushLastCell() throws Exception {
			State state = read("""
		
				Global 
				^12 6
				Optional State : 
				^ 26
				^17 11
				^0 0 0 0 0 0 0 0 3081 3107 0 0 
				^0 0 0 19462 11282 0 0 0 0 0 0 0 
				^0 5126 0 5126 17414 15366 13318 0 9222 3078 0 0 
				^0 3078 5126 9222 0 9222 7186 9234 5126 0 0 0 
				^0 0 0 5126 0 0 0 0 11270 0 0 0 
				^0 0 0 0 0 4752 0 0 17414 13394 16896 0
			  """);
		
			List<Action> commands = ai.think(state);
			
			assertThat(commands)
							.contains(Action.move(2, Pos.from(9,5), Pos.from(10,5), "TEST"))
							;
		}
	}	
	
	
	public static State read(String input) {
		input = input + "\n^  ";
		String cleanInput = Stream.of(input.split("\n"))
				.filter(s -> s.length() != 0 && s.charAt(0) == '^')
				.map(s -> s.replace("^", " ").concat("\n")) // remove ^
				.collect(Collectors.joining());
		FastReader in = FastReader.fromString(cleanInput);
		State state = new State();
		
		state.readGlobal(in);
    state.readOptionalState(in);
    state.readPacked(in);
		
		return state;
	}
}
